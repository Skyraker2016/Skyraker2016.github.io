<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Facial Landmark Machines: A Backbone-Branches Architecture with Progressive Representation Learning 论文阅读笔记]]></title>
    <url>%2F2019%2F07%2F17%2FFacial-Landmark-Machines-A-Backbone-Branches-Architecture-with-Progressive-Representation-Learning-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[论文链接 主要工作本文将面部特征点检测问题看作像素级的分类问题，提出了一种级联主干分支全卷积网络BB-FCN用于面部特征点检测，包括两部分：（1）主干网络，用于粗粒度地检测面部特征点的位置；（2）分支网络，更进一步地分别对各个面部特征点作细化处理。该工作解决了以下问题： 非受控环境下的面部特征点检测，包括不确定的人脸数量、位置、动作、光线等。论文提出的方法能够在没有预处理的前提下对非受控环境有很好效果； 性能与检测效果的冲突：Boosted-cascade-based fast face detectors虽然速度较快，但仅在正脸上取得良好效果；accurate deformable-part-based models虽然能够得到更精确的结果，但是由于过于复杂速度较慢。同时，人脸检测需要消耗数秒，导致其不实用。 该模型的效果能够在不受控环境中获得很好的效果，而不需要预处理过程。同时，为了训练模型在非受控环境下的鲁棒性，论文还建立了一个SYSU16K数据集，包含非受控条件下，光照、动作、分辨率变化很大的16,000张图片。 具体方法问题定义考虑非受限的输入图像$I$，我们需要对每张脸检测$K$个特征点（例如$K=5$时，认为每张脸5个特征点，分别是左右眼、鼻子、左右嘴角；另外，$K$可改变提供了模型的灵活性）。对于图像$I$的特征点检测即得到以下点集： $Det(I)={(x_i^k,y_i^k)}_{i,k}$，其中，$k=1, 2, …K$，$i$代表第$i$张脸。 在该论文中，把特征点检测看作了一种”像素级分类“的问题，类似于图像分割。在此之前，人脸特征点检测一般将该问题构建为两种问题，模板拟合问题或回归问题： 模板拟合问题，即建立面部模板来对输入的人脸进行拟合。将人脸特征点检测问题看作模板拟合问题有两种方法：对于全局的特征提取的方法，或按照面部模板对局部特征提取的方法；后者一般比前者鲁棒性更强，因为局部检测能够避免光照和遮罩的问题。 回归问题。回归问题可以分为映射问题和级联回归模型。直接映射是指将图像内容通过回归映射至特征点的坐标；级联回归模型是以一个初始的面部形状开始，用回归器做图形优化，不断迭代直至收敛。 通过将特征点检测问题转换为像素级分类的问题，就可以借鉴图像像素级分割、实体检测的方法，选用在该任务中表现很好的FCN（全卷积神经网络），看作对该图像的深度特滤波器；同时，FCN可以天然地支持对任意大小的图像输入，并映射至对应的空间中。在论文的方法中，对每个位置的预测值，可以看作为一组的滤波器应用在对应感受域上的结果。一组优秀的滤波器需要在正确的位置得到高的响应值，而在其它位置响应值结果要低。为此，定义滤波器$F_{W^k}$，$W^k$代表第$k$类特征点的模型参数；定义$P$为一个接受域。一个理想的模型输出如下： 更进一步地，利用大小为$(w, h)$的窗口对图像进行接受域的采样，在$I$上构建了一个相应图$F_{W^k}*I$，坐标$(x, y)$对应的点的响应值为： 得到全图的响应值后，设置一个阈值$\theta$，中心点的响应值大于$\theta$的点即为我们要求的点集$Det(I)$： 模型结构论文指出，由公式(3)可以看出，运算速度与精确度存在对抗；即当我们取的感受域越重叠（密集）时，我们的准确率越高，但为了提高速度，我们又应该粗粒度地选区感受域。为此，一般考虑结合粗粒度和细粒度的模型，构建一个级联模型。在论文的方法中，该级联模型分为两部分： 相对低分辨率的图像 -&gt; 粗粒度相应图 粗粒度相应图-&gt;以粗粒度特征点为中心选区局部区域-&gt;每个局部区域得到的细粒度相应图 以上步骤避免了对整张图进行细粒度的操作，提升了速度；对概率较高的位置（粗粒度相应图选择的特征点周围）做了进一步细化，保证了准确率。该级联模型被论文称为BB-FCN，即Backbone-Branch FCN，如下图所示： 如图，主干(backbone)网络如前所述，通过全卷积神经网络提取出粗粒度的区域（例如眼镜、鼻子）；分支(branch)网络由K个分支组成，每一个分支负责一个特征点类别，对前面所提到的不同特征点的粗粒度区域作进一步的细化操作，例如在左眼的区域范围内找到瞳孔。 主干网络主干网是一个FCN，可以有效地为输入图像生成一个初始的低分辨率响应图。当在对不受限的图像面部标志进行定位时，它可以帮助我们利用阈值，拒绝大多数背景区域。定义$H^k(I;W_c)$代表第$k$类特征点在图像$I$对应的响应图，$W_c$为模型参数。可以利用上述的公式(3)来得到对应位置的响应值。主干网络的损失值定义为： 其中，$H_c^k(I)$为ground-truth。 在训练阶段，将人脸从不受限的拥挤环境中截取出来，并降低至32*32的分辨率中；同时，主干网络不对特征点作区分。这两个训练设置是为了让模型隐式地学到在一个人脸的各个特征点之间的相对约束。例如，模型可以学到两眼之间偏下一般对应鼻子这类信息。 分支网络分支网络由$K$个不同的分支组成，每个分支对应一种特征点。输入为原始图像与主干网络输出响应图的对应位置叠合，形成RGB+主干输出的4通道图作为输入。为了更好地检测特征点，将输入的原始图像resize为64*64，主干网络生成的响应图也是如此；每一个特征点对应的输入图为24*24，即前文提到的以粗粒度landmarks为中心的方形区域。 与主干网络类似地，设置$H(P;W_f^k)$代表在区域$P$中的响应热力图，$W_f^k$为模型参数。损失值为： 训练设置Ground-Truth的生成一般地认为，将landmarks对应的坐标设为1，其它位置设为0即可。然而由于标注的偏差，可能存在多个孤立的特征点于同一区域内，都可以认为是正确的。因此论文提出用区域代替原本的孤立点作为ground-truth的特征：如下图的嘴角，用一个区域代替原本的landmark点： 同时，对粗粒度和细粒度的区域范围做了区分，分别是$R_c$（coarse，粗粒度）与$R_f$（fine，细粒度），显然需要$R_c&gt;R_f$，即要求细粒度模型获得更加精准的位置。 选择响应图训练我们知道，对于一个图像而言，landmarks所占据的区域是远少于其它的，因此我们可以看作是样本的极大的不平衡，即正例过少。因此，论文采用了一种选择性方案，即随机选择与ground-truth响应图中的landmarks位置相同数量的非landmarks位置来传播误差，同时抑制误差反向传播过程中所有其他非地标位置。对于一些看不见的landmarks或背景图像，landmarks没有正区域，我们只选择一小部分非landmarks位置进行传播。这种选择性的训练方案对于确保了训练的收敛。此外，在验证集的loss下降停止后，选择hard negative samples（输出值过大的负例）进行反向传播。通过这种方法，能够定向地惩罚一些很明显的错误结果。 其它的训练细节（包括优化器、超参数、样本划分等）详见论文III-E部分，不再细述；特别地，对于受控和非受控环境论文有不同的设置。 实验结果由于现有的数据集过小，且采样过于狭窄（有的只有正脸），因此论文建立了一个名为SYSU16K的数据集，包括7k+的非受控图像。同时从Pascal-VOC2012选取了7000+自然风景图作为负样本。 论文在LFPW, AFW, AFLW， 300W 数据集上做了测试。度量为： 其中，$l$为眼间距。 整体效果：可以看到，对于非受控条件，即便人脸数量、人脸位置未知，模型依然能够给出很好的效果。 级联效果：通过控制是否使用分支网络来衡量粗细粒度级联模型带来的提升，可以看出，采取了级联效果的AUC在所有的分类器不同的人脸数量中都是最高的。 将分支网络对主干网络细化的效果进行可视化： 与其它方法的对比：错误率低于state-of-the-art方法： 鲁棒性测试：在不同的分辨率、光照、人脸、姿势中的效果： 更密集的landmarks探测，即改变$K$的大小： 运行效率： 总结笔者认为这篇论文有以下几个亮点值得我们借鉴学习： 将特征点检测转换为像素级分类问题，不仅通过概率热力图能够对实验结果进行直观的表达，而且能够借鉴在该领域上表现优秀的FCN模型；FCN除了其性能优秀外，还能够对任意大小的图像输入进行支持。 结合粗粒度与细粒度两阶段的级联策略，能够在速度和准确率上都得到较好的效果。粗粒度即可以是预检测目标位置的大致范围，也可以是降低图像分辨率； 主干网络的训练设置，以单独人脸作为训练输入，且将所有特征的响应图共同生成，这一细节能够隐式让模型学到不同特征点间的约束； 考虑到了人为标注的误差，用区域代替孤立点作为ground-truth； 在真值响应图上进行选择训练，保障了样本的均衡性； 在验证集停止下降的时候，利用hard negative samples进行反向传播; 建立了自己的in the wild 数据集，并在VOC2012上的自然分类中采样了负样本。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cuda+VS2016配置]]></title>
    <url>%2F2018%2F07%2F08%2FCuda-VS2016%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[先按照这个教程的步骤安装配置好CUDA9.0和vs，并新建一个CUDA项目。以下对该教程的vs2017的项目配置作一些补充： 选择平台：在项目右键-&gt;属性-&gt;平台（在窗口顶部）选择(x64) 降级项目至vs2015：由于CUDA9.0依旧无法适合vs2017正式版，详见百度贴吧。因此要将项目降级至vs2015进行编译： 若未安装vs2015工具集，先在vs installer 中选择 修改-&gt;单个组件-&gt;适用于桌面的vc++2015.3 v14.00（v140）工具集进行安装 在项目右键-&gt;属性-&gt;配置属性-&gt;平台工具集的选项中选择下拉菜单，若已安装vs2015则会有相应的工具集，选择Visual Studio 2015 (v140) 连接器配置：在项目右键-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项，编辑，添加如下： 1cublas.lib;cuda.lib;cudadevrt.lib;cudart.lib;cudart_static.lib;nvcuvid.lib;OpenCL.lib 注意cublas.lib是原教程没有的。 最后进行生成，应该就能够运行成功了。]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业 sklearn习题]]></title>
    <url>%2F2018%2F06%2F20%2Fpython%E4%BD%9C%E4%B8%9A-sklearn%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学习sklearn库，进行数据的生成、分组、回归及算法性能分析。 步骤 数据生成 1dataset = datasets.make_classification(n_samples=1000, n_features=10,n_informative=2, n_redundant=2, n_repeated=0, n_classes=2) 数据分组 12345kf = cross_validation.KFold(len(data), n_folds=10, shuffle=True)for train_index, test_index in kf:X_train, y_train = data[train_index], target[train_index]X_test, y_test = data[test_index], target[test_index] 对于每组数据，进行回归： Gaussian Navie Bayes： 123clf = GaussianNB()clf.fit(X_train, y_train)pred = clf.predict(X_test) SVC: 123clf = SVC(C=1, kernel='rbf')clf.fit(X_train, y_train)pred = clf.predict(X_test) Random Forest: 123clf = RandomForestClassifier(n_estimators=100)clf.fit(X_train, y_train)pred = clf.predict(X_test) 数据分析： accuracy： 1metrics.accuracy_score(y_test, pred) F1-score： 1metrics.f1_score(y_test, pred) AUC ROC： 1metrics.roc_auc_score(y_test, pred) 总代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from sklearn import datasets, cross_validationfrom sklearn.naive_bayes import GaussianNBfrom sklearn.svm import SVCfrom sklearn.ensemble import RandomForestClassifierfrom sklearn import metrics# create a classification datasetdataset = datasets.make_classification(n_samples=1000, n_features=10,n_informative=2, n_redundant=2, n_repeated=0, n_classes=2)data = dataset[0]target = dataset[1]# Split the dataset using 10-fold cross validationkf = cross_validation.KFold(len(data), n_folds=10, shuffle=True)acc = &#123;"GaussianNB":[], "SVC":[], "RandomForest":[]&#125;f1 = &#123;"GaussianNB":[], "SVC":[], "RandomForest":[]&#125;auc = &#123;"GaussianNB":[], "SVC":[], "RandomForest":[]&#125;for train_index, test_index in kf: X_train, y_train = data[train_index], target[train_index] X_test, y_test = data[test_index], target[test_index] # GaussianNB clf = GaussianNB() clf.fit(X_train, y_train) pred = clf.predict(X_test) acc["GaussianNB"].append( metrics.accuracy_score(y_test, pred) ) f1["GaussianNB"].append( metrics.f1_score(y_test, pred) ) auc["GaussianNB"].append( metrics.roc_auc_score(y_test, pred) ) # SVC (possible C values [1e-02, 1e-01, 1e00, 1e01, 1e02], RBF kernel) clf = SVC(C=1, kernel='rbf') clf.fit(X_train, y_train) pred = clf.predict(X_test) acc["SVC"].append( metrics.accuracy_score(y_test, pred) ) f1["SVC"].append( metrics.f1_score(y_test, pred) ) auc["SVC"].append( metrics.roc_auc_score(y_test, pred) ) # RandomForestClassifier (possible n estimators values [10, 100, 1000]) clf = RandomForestClassifier(n_estimators=100) clf.fit(X_train, y_train) pred = clf.predict(X_test) acc["RandomForest"].append( metrics.accuracy_score(y_test, pred) ) f1["RandomForest"].append( metrics.f1_score(y_test, pred) ) auc["RandomForest"].append( metrics.roc_auc_score(y_test, pred) )print("acc: ")for item in acc.items(): print("--- "+item[0] +": " + str(sum(item[1])/len(item[1])) )print("f1: ")for item in f1.items(): print("--- "+item[0] +": " + str(sum(item[1])/len(item[1])) )print("auc: ")for item in auc.items(): print("--- "+item[0] +": " + str(sum(item[1])/len(item[1])) ) 结果123456789101112acc:--- GaussianNB: 0.885--- SVC: 0.9109999999999999--- RandomForest: 0.9199999999999999f1:--- GaussianNB: 0.8814437089165666--- SVC: 0.907042930534323--- RandomForest: 0.9176129601622535auc:--- GaussianNB: 0.8832256906743698--- SVC: 0.9101616490472964--- RandomForest: 0.9190646809857602]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业 Jupyter练习]]></title>
    <url>%2F2018%2F06%2F11%2Fpython%E4%BD%9C%E4%B8%9A-Jupyter%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介Jupyter Notebook可以让你在浏览器上运行的笔记本，支持实时代码运算、生成图像，是很多数据科学工作者的选择。 习题 在博客中插入jupyter：参考自这个教程。首先将ipynb文件上传至github，打开这个网页，输入自己的用户名,在自己的仓库中找到ipynb文件，打开，复制其url，例如1https://nbviewer.jupyter.org/github/Skyraker2016/markdownpic/blob/master/Exercises.ipynb 在博客中插入 1&lt;iframe src="your_URL" width="700" height="400"&gt;&lt;/iframe&gt; 其中width和height分别是jupyter框的宽度和长度。 注意，https的网页不能嵌套http的网页]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Scipy库习题]]></title>
    <url>%2F2018%2F06%2F05%2FScipy%E5%BA%93%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Learning scipy Exercise 10.1: Least squaresGenerate matrix A ∈ $R_{m×n}$ with m &gt; n. Also generate some vector b ∈ $R_m$ .Now find $x=arg \min_x||Ax-b||_2$. Print the norm of the residual. Code1234567891011121314import numpy as npimport scipy.linalgm = 20n = 10A = np.random.rand(m, n)b = np.random.rand(m).reshape(m, 1)x = scipy.linalg.lstsq(A, b)[0]print("x = "+str(x))err = A.dot(x) - bresidual = scipy.linalg.norm(err,ord=2)print("norm of the residual: "+str(residual)) Result1234567891011x = [[ 0.29354894] [ 0.3171796 ] [ 0.3076955 ] [ 0.16784761] [ 0.37531644] [-0.12455975] [ 0.24540134] [ 0.17275431] [-0.28511405] [-0.52271425]]norm of the residual: 0.7740732857559364 Exercise 10.2: OptimizationFind the maximum of the function$$ f(x) = sin^2(x-2)e^{-x^2}$$ Code12345678import numpy as npimport scipy.linalgimport scipy.optimizef = lambda x: -scipy.sin(x-2)**2*(x-2)*scipy.exp(-(x*x))# 由于只有取最小值的方法，因此要取反函数并对答案取反res = scipy.optimize.fmin(f, scipy.rand(), full_output=True)print("Max of the func: "+str(-res[1])) Result12345Optimization terminated successfully. Current function value: -0.000225 Iterations: 20 Function evaluations: 40Max of the func: 0.0002253477813642845 Exercise 10.3: Pairwise distancesLet X be a matrix with n rows and m columns. How can you compute the pairwise distances between every two rows? As an example application, consider n cities, and we are given their coordinates in two columns. Now we want a nice table that tells us for each two cities, how far they are apart. Again, make sure you make use of Scipy’s functionality instead of writing your own routine. Code1234567891011import numpy as npimport scipy.spatial.distancem, n = 4, 3# 4 cities, x,y,z to discribe a cityA = np.random.rand(m,n)print("4 Cities: ")print(A)D = scipy.spatial.distance.pdist(A)print("Distance between each 2 cities: ")print(D) Result12345674 Cities:[[0.42422873 0.17197828 0.82144308] [0.15882959 0.42992466 0.80128027] [0.7649197 0.21990926 0.38651754] [0.75747478 0.15525905 0.16286141]]Distance between each 2 cities:[0.37064751 0.55455201 0.73828332 0.7638585 0.91727634 0.23293162]]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于assimp库的模型加载]]></title>
    <url>%2F2018%2F06%2F04%2F%E5%9F%BA%E4%BA%8Eassimp%E5%BA%93%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[使用assimp库进行模型文件的加载与操作环境说明 开发环境: Linux 库: assimp， glew， glfw， glut 运行环境: Linux 编译指令 1g++ -o loadModel loadModel.cpp -lGL -lGLU -lglut -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lpthread -lGLEW -ldl -lassimp 文件说明 12345678.├── bunny.ply #兔子模型 ├── cow.obj #奶牛模型├── loadModel #可执行文件├── loadModel.cpp #主程序├── Mesh.hpp #Mesh库├── Model.hpp #Model库└── readme.md 功能说明可加载常用的模型文件(obj, ply …)，并能进行平移、缩放与旋转，支持三种查看模式——wire、flat、flat lines 运行方法将可执行文件与待加载的模型文件（obj、ply等）放在同一目录下，linux命令行下运行：1./loadModel name 其中name为模型文件完整文件名 操作说明 空格：切换查看模式wire, flat, flat lines 鼠标滚轮：缩放模型 鼠标拖拽：移动模型 方向键：旋转模型 运行效果 旋转 切换显示模式 平移 缩放 加载ply格式的bunny 实现思路安装与连接assimpUbuntu下安装assimp库：12sudo apt-get install libassimp-devsudo apt-get install assimp-utils 编译链接1g++ ... -lassimp 模型类模型类的思路参考learningopengl，但去掉了纹理相关（还未开始学习），以及将绘制相关的绑定缓冲区、自定义着色器改为glut实现。 数据结构: 123456789101112131415//模型类——包含meshesclass Model vector&lt;Mesh&gt; meshes;//Mesh类——包含顶点及面索引class Mesh vector&lt;Vertex&gt; vertices; vector&lt;GLuint&gt; indices;//顶点，包含坐标及法向量struct Vertex&#123; vector&lt;GLfloat&gt; pos; vector&lt;GLfloat&gt; nor;&#125;; 加载: 读入一个模型文件 123456789101112131415161718void loadModel(string path)&#123; Assimp::Importer importer; const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenSmoothNormals); //模型文件path为路径 //aiProcess_Triangulate 使文件以三角形作为图元生成 //aiProcess_GenSmoothNormals 为没有法向量的顶点设置法向量 //加载错误，反馈信息 if(!scene || scene-&gt;mFlags == AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) // if is Not Zero &#123; cout &lt;&lt; "ERROR::ASSIMP:: " &lt;&lt; importer.GetErrorString() &lt;&lt; endl; return; &#125; //进行递归遍历节点 this-&gt;processNode(scene-&gt;mRootNode, scene);&#125; 通过递归遍历模型的节点及mesh： 1234567891011121314151617void processNode(aiNode* node, const aiScene* scene)&#123; // 便利节点上的每个mesh for(GLuint i = 0; i &lt; node-&gt;mNumMeshes; i++) &#123; //加载mesh aiMesh* mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]]; this-&gt;meshes.push_back(this-&gt;processMesh(mesh, scene)); &#125; //遍历子节点 for(GLuint i = 0; i &lt; node-&gt;mNumChildren; i++) &#123; this-&gt;processNode(node-&gt;mChildren[i], scene); &#125;&#125; 读取mesh的每个顶点： 12345678910111213141516171819202122232425262728293031323334Mesh processMesh(aiMesh* mesh, const aiScene* scene)&#123; // Data to fill vector&lt;Vertex&gt; vertices; vector&lt;GLuint&gt; indices; // Walk through each of the mesh's vertices for(GLuint i = 0; i &lt; mesh-&gt;mNumVertices; i++) &#123; vector&lt;GLfloat&gt; vertex(3); vertex[0] = mesh-&gt;mVertices[i].x; vertex[1] = mesh-&gt;mVertices[i].y; vertex[2] = mesh-&gt;mVertices[i].z; Vertex tmp; tmp.pos = vertex; vertex[0] = mesh-&gt;mNormals[i].x; vertex[1] = mesh-&gt;mNormals[i].y; vertex[2] = mesh-&gt;mNormals[i].z; tmp.nor = vertex; vertices.push_back(tmp); &#125; // Now wak through each of the mesh's faces (a face is a mesh its triangle) and retrieve the corresponding vertex indices. for(GLuint i = 0; i &lt; mesh-&gt;mNumFaces; i++) &#123; aiFace face = mesh-&gt;mFaces[i]; // Retrieve all indices of the face and store them in the indices vector for(GLuint j = 0; j &lt; face.mNumIndices; j++) indices.push_back(face.mIndices[j]); &#125; // Return a mesh object created from the extracted mesh data return Mesh(vertices, indices);&#125; 绘制 函数实现 12345678910111213141516171819//Mesh类中void Draw(GLenum style, int size) &#123; //遍历三角面 for (int i=0; i&lt;indices.size(); i+=3)&#123; //style为绘制模式，GL_LINE_LOOP为线框，GL_TRIANGLES为三角面 glBegin(style); //Normal为法线，用于光照运算 //vertex为顶点坐标 //size为放缩的倍数，初始为400，用于滚轮缩放 glNormal3f(vertices[indices[i]].nor[0]*size, vertices[indices[i]].nor[1]*size, vertices[indices[i]].nor[2]*size); glVertex3f(vertices[indices[i]].pos[0]*size, vertices[indices[i]].pos[1]*size, vertices[indices[i]].pos[2]*size); glNormal3f(vertices[indices[i+1]].nor[0]*size, vertices[indices[i+1]].nor[1]*size, vertices[indices[i+1]].nor[2]*size); glVertex3f(vertices[indices[i+1]].pos[0]*size, vertices[indices[i+1]].pos[1]*size, vertices[indices[i+1]].pos[2]*size); glNormal3f(vertices[indices[i+2]].nor[0]*size, vertices[indices[i+2]].nor[1]*size, vertices[indices[i+2]].nor[2]*size); glVertex3f(vertices[indices[i+2]].pos[0]*size, vertices[indices[i+2]].pos[1]*size, vertices[indices[i+2]].pos[2]*size); glEnd(); &#125;&#125; 12345678//Model类中void Draw(GLenum style, int size)&#123; //遍历mesh绘制 for(GLuint i = 0; i &lt; this-&gt;meshes.size(); i++)&#123; this-&gt;meshes[i].Draw(style, size); &#125;&#125; 主循环中绘制 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void display(Model &amp;test)&#123; //清缓存 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //保存上一个变换矩阵，本项目中不用 // glPushMatrix(); //加载单位矩阵 glLoadIdentity(); //透视矩阵 gluPerspective(60.0, 1, 400, -400); //摄像矩阵 gluLookAt(0, 0, 800, 0, 0, 0, 0, 1, 0); //鼠标拖拽时进行相应的移动 if (clicking)&#123; tx -= moveX; ty += moveY; &#125; moveX = moveY = 0; //平移 glTranslatef(tx, ty, 0.0f); //旋转 glRotatef(angle_ud,1,0,0); glRotatef(angle_rl,0,1,0); //以上矩阵生效顺序是从下至上 //设置默认颜色 glColor3f(1.0, 1.0, 1.0); //根据模式来进行绘制 switch(sstyle)&#123; case 0: //wire glLineWidth(1.0f); test.Draw(GL_LINE_STRIP,ssize); break; case 1: //flat test.Draw(GL_TRIANGLES,ssize); break; case 2: //flat lines glColor3f(0.8, 0.8, 0.8); test.Draw(GL_TRIANGLES,ssize); glLineWidth(1.5f); glColor3f(0.2, 0.2, 0.2); test.Draw(GL_LINE_STRIP,ssize); break; &#125; // glPopMatrix();&#125; 交互： 注册事件： 123456void setEvents(GLFWwindow * window)&#123; glfwSetKeyCallback(window, key_callback); //键盘事件 glfwSetMouseButtonCallback(window, mouse_click_callback); //鼠标按键 glfwSetCursorPosCallback(window, mouse_move_callback); //鼠标移动 glfwSetScrollCallback(window, scroll_callback); //鼠标滚轮&#125; 键盘——旋转、切换： 1234567891011121314151617181920212223242526//键盘事件回调函数void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; //退出 if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) &#123; glfwSetWindowShouldClose(window, GL_TRUE); &#125; //旋转 else if (key == GLFW_KEY_LEFT &amp;&amp; action == GLFW_REPEAT)&#123; angle_rl -= 1; &#125; else if (key == GLFW_KEY_RIGHT &amp;&amp; action == GLFW_REPEAT)&#123; angle_rl += 1; &#125; else if (key == GLFW_KEY_UP &amp;&amp; action == GLFW_REPEAT)&#123; angle_ud -= 1; &#125; else if (key == GLFW_KEY_DOWN &amp;&amp; action == GLFW_REPEAT)&#123; angle_ud += 1; &#125; //切换style else if (key == GLFW_KEY_SPACE &amp;&amp; action == GLFW_PRESS)&#123; sstyle = (sstyle+1)%3; &#125; &#125; 1234567891011//旋转相关变换//旋转全局数据GLfloat angle_rl = 0;GLfloat angle_ud = 0;...//in display()glRotatef(angle_ud,1,0,0);glRotatef(angle_rl,0,1,0); 123456789101112131415161718192021222324//切换style//style全局数据int sstyle = 0;...//in display()switch(sstyle)&#123; case 0: //wire glLineWidth(1.0f); test.Draw(GL_LINE_STRIP,ssize); break; case 1: //flat test.Draw(GL_TRIANGLES,ssize); break; case 2: //flat lines glColor3f(0.8, 0.8, 0.8); test.Draw(GL_TRIANGLES,ssize); glLineWidth(1.5f); glColor3f(0.2, 0.2, 0.2); test.Draw(GL_LINE_STRIP,ssize); break;&#125; 鼠标——拖拽、缩放： 拖拽 123456789101112//全局鼠标坐标数据//平移向量GLfloat tx = 0;GLfloat ty = 0;//移动速度GLfloat moveX = 0;GLfloat moveY = 0;//鼠标位置GLfloat mouseX = 0;GLfloat mouseY = 0;//是否正在拖拽bool clicking = false; 12345678910111213141516171819//回调函数//实时记录鼠标位置及移动趋势void mouse_move_callback(GLFWwindow* window, double xpos, double ypos)&#123; //记录鼠标移动趋势——通过当前坐标与上一坐标计算 moveX = mouseX - xpos; moveY = mouseY - ypos; //记录鼠标当前坐标 mouseX = xpos; mouseY = ypos;&#125;//通知全局鼠标是否按下（即拖拽中）void mouse_click_callback(GLFWwindow* window, int button, int action, int mods)&#123; if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; action == GLFW_PRESS)&#123; clicking = true; &#125; if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; action == GLFW_RELEASE)&#123; clicking = false; &#125;&#125; 12345678910// in display()//鼠标拖拽时进行相应的移动if (clicking)&#123; tx -= moveX; ty += moveY;&#125;// 将运动趋势归零防止惯性moveX = moveY = 0;//平移变换glTranslatef(tx, ty, 0.0f); 滚轮缩放 123// 全局数据// 缩放倍数int ssize = WIDTH/2; 123456// 回调函数void scroll_callback (GLFWwindow* window, double xoffset, double yoffset)&#123; //yoffset 是滚轮转动的程度 ssize += 5*yoffset;&#125; 1234567891011121314151617181920//in Mesh class//先前得到的ssize交给draw方法进行顶点坐标的放缩并绘制void Draw(GLenum style, int size) &#123; //遍历三角面 for (int i=0; i&lt;indices.size(); i+=3)&#123; //style为绘制模式，GL_LINE_LOOP为线框，GL_TRIANGLES为三角面 glBegin(style); //Normal为法线，用于光照运算 //vertex为顶点坐标 //size为放缩的背书，初始为400，用于滚轮缩放 glNormal3f(vertices[indices[i]].nor[0]*size, vertices[indices[i]].nor[1]*size, vertices[indices[i]].nor[2]*size); glVertex3f(vertices[indices[i]].pos[0]*size, vertices[indices[i]].pos[1]*size, vertices[indices[i]].pos[2]*size); glNormal3f(vertices[indices[i+1]].nor[0]*size, vertices[indices[i+1]].nor[1]*size, vertices[indices[i+1]].nor[2]*size); glVertex3f(vertices[indices[i+1]].pos[0]*size, vertices[indices[i+1]].pos[1]*size, vertices[indices[i+1]].pos[2]*size); glNormal3f(vertices[indices[i+2]].nor[0]*size, vertices[indices[i+2]].nor[1]*size, vertices[indices[i+2]].nor[2]*size); glVertex3f(vertices[indices[i+2]].pos[0]*size, vertices[indices[i+2]].pos[1]*size, vertices[indices[i+2]].pos[2]*size); glEnd(); &#125;&#125; 光照：若如果没有光照，flat模式就会变成一片剪影（如图），因此特意为其添加光照效果 1234567891011121314151617181920//光照设置// 激活光照计算glEnable(GL_LIGHTING);GLfloat light_position[] = &#123; -1.0, 0.3, 0, 0.0 &#125;; //光源位置glLightfv(GL_LIGHT0, GL_POSITION, light_position); //设置光源位置GLfloat light_color[] = &#123; 0.05, 0.05, 0.05, 1.0 &#125;; //光源颜色glLightfv(GL_LIGHT0, GL_DIFFUSE, light_color); //设置光源颜色//激活以上设置的0号光源glEnable(GL_LIGHT0); // 指定环境光强度（RGBA）GLfloat ambientLight[] = &#123;0.4f, 0.4f, 0.4f, 1.0f&#125;;// 设置光照模型，将ambientLight所指定的RGBA强度值应用到环境光glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ambientLight);// 启用颜色追踪，为了能够在光照反射时能反应颜色glEnable(GL_COLOR_MATERIAL);// 设置多边形正面的环境光和散射光材料属性，追踪glColorglColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); 得到有光照模型： 完整代码参考链接 assimp基础及模型类参考 光照设置 顶点法线的光照意义 glBegin() glut的旋转变换 glut的平移变换 滚轮事件 斯坦福bunny兔模型下载]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bezier三次曲线]]></title>
    <url>%2F2018%2F05%2F30%2FBezier%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/Bezier文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./Bezier 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM 编译参数：1g++ -o Bezier Bezier.cpp -lGL -lGLU -lglut -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lpthread -lGLEW -ldl 功能说明： 鼠标左键点击，选择四个点绘制成相应的bezier三次曲线 回车键保留该曲线，并去除草稿线 退格键删除上一条曲线 效果演示： 绘制一条曲线 删除曲线 兔子 知识点 获取鼠标位置：鼠标移动回调函数： 1234void mouse_move_callback(GLFWwindow* window, double xpos, double ypos)&#123; mouseX = xpos; mouseY = ypos;&#125; Bezier公式： $$ B(t) = P_0(1-t)^3 + 3P_1t(1-t)^2+3P_2t^2(1-t)+P_3t^3, t \in [0,1] $$ 具体实现： 12345678910111213141516void bezier(vector&lt;vector&lt;GLfloat&gt;&gt; &amp;line, int n)&#123; float step = 1.0f / n; float a, b, c, d; for (int i=0; i&lt;=n; i++)&#123; float these = step * i; a = (1-these) * (1-these) * (1-these); b = (1-these) * (1-these) * these * 3; c = (1-these) * these * these * 3; d = these * these * these; vector&lt;GLfloat&gt; tmp; tmp.push_back(a * pos[0][0] + b * pos[1][0] + c * pos[2][0] + d * pos[3][0]); tmp.push_back(a * pos[0][1] + b * pos[1][1] + c * pos[2][1] + d * pos[3][1]); tmp.push_back(a * pos[0][2] + b * pos[1][2] + c * pos[2][2] + d * pos[3][2]); line.push_back(tmp); &#125;&#125; 源代码参考绘制bezier曲线]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib库学习]]></title>
    <url>%2F2018%2F05%2F29%2FMatplotlib%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Learning matplotlib, a lib to draw chart, figure, etc.. Exercise 11.1: Plotting a functionPlot the function$$ f(x) = sin^2(x-2)e^{-x^2} $$over the interval [0, 2]. Add proper axis labels, a title, etc. Code1234567891011import matplotlib.pyplot as plt import numpy as npplt.figure(1)x = np.linspace(0, 2, 100)y = [ np.sin( x[i] - 2 ) ** 2 * np.exp(- x[i]*x[i]) for i in range(len(x)) ]plt.plot(x,y)plt.title('f(x) = sin^2(x-2)*e^(-x^2)')plt.xlabel('x')plt.ylabel('y')plt.show() Result Knowledge 用pip3 install matplotlib进行安装 遇到问题ModuleNotFoundError: No module named &#39;tkinter&#39;，按教程解决，即用apt install python3-tk安装。 用plot绘制曲线，xlabel、ylabel设置坐标轴名称，title设置图像标题 Exercise 11.2: DataCreate a data matrix X with 20 observations of 10 variables. Generate a vector b with parameters. Then generate the response vector $y = Xb+z$ where z is a vector with standard normally distributed variables. Now (by only using y and X), find an estimator for b, by solving$$ \hat{b} = arg\min\limits_{b} || Xb-y ||_2 $$Plot the true parameters b and estimated parameters b̂. See Figure 1 for an example plot. Code1234567891011121314151617import matplotlib.pyplot as plt import numpy as npX = np.random.rand(20, 10) * 10 # 增长10倍增大差异b = np.random.rand(10, 1)z = np.random.normal(size=(20, 1))y = X.dot(b) + zx = np.linspace(0, 9, 10)b_ = np.array( np.linalg.lstsq(X, y)[0] )plt.scatter( x, b, c='r', marker='o', label='b')plt.scatter( x, b_, c='b', marker='+', label='$\hat&#123;b&#125;$')plt.legend()plt.show() Result Knowledge .dot()点乘 lstsq()最小二乘法 scatter散点图 legend显示图例 Exercise 11.3: Histogram and density estimationGenerate a vector z of 10000 observations from your favorite exotic distribution. Then make a plot thatshows a histogram of z (with 25 bins), along with an estimate for the density, using a Gaussian kerneldensity estimator (see scipy.stats). See Figure 2 for an example plot. Code12345678910import matplotlib.pyplot as plt import numpy as npfrom scipy import statsz = np.random.normal(0,100,size=(10000,))kernel = stats.gaussian_kde(z)x = np.linspace(-400, 300, 10000)plt.hist(z, 25,rwidth=0.8, density=True)plt.plot(x, kernel.evaluate(x), label='kde')plt.show() Result Knowledge hist to draw a histogram scipy.stats.gaussian_kde to create Gaussian kernel density estimator.]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Numpy库学习]]></title>
    <url>%2F2018%2F05%2F22%2FNumpy%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Learning Numpy, a lib of python with matrix and other calculation. PrepareGenerate matrices A, with random Gaussian entries, B, a Toeplitz matrix, where A ∈Rn×m and B ∈Rm×m, for n = 200, m = 500. Code123456789101112import numpy from scipy.linalg import toeplitznumpy.random.seed()n = 200m = 500A = numpy.random.normal(size = [n, m])B = toeplitz(numpy.random.normal(size=m))print("------------A-----------\n"+str(A))print("------------B-----------\n"+str(B)) Result123456789101112131415161718192021222324252627[[-0.49837536 -0.3247838 0.50678674 ..., -1.2703934 0.76603943 0.03755445] [-0.03462894 -0.21418493 1.22520135 ..., 0.84866266 0.40158282 -0.65401731] [ 1.1291174 0.49403126 -0.28698245 ..., 0.61324651 0.73156374 -1.58197964] ..., [-0.68737602 -0.89741706 0.12970931 ..., -0.82061635 0.09854131 1.00242481] [-0.31053207 -0.05350655 -1.51289055 ..., -2.26626492 0.79240834 -0.73548947] [ 0.29646267 0.44302565 1.34552379 ..., 0.12526137 -0.74942753 -1.40240914]]------------B-----------[[ 1.44784231 -0.33696399 -0.1432767 ..., 0.26606438 -0.09475546 -1.50552307] [-0.33696399 1.44784231 -0.33696399 ..., -1.16119122 0.26606438 -0.09475546] [-0.1432767 -0.33696399 1.44784231 ..., -1.39562368 -1.16119122 0.26606438] ..., [ 0.26606438 -1.16119122 -1.39562368 ..., 1.44784231 -0.33696399 -0.1432767 ] [-0.09475546 0.26606438 -1.16119122 ..., -0.33696399 1.44784231 -0.33696399] [-1.50552307 -0.09475546 0.26606438 ..., -0.1432767 -0.33696399 1.44784231]] Knowledge random.normal() to create a matrix with Gaussian entries. toepltitz() to create a toepltitz matrix. random.seed() , without argument, set random seed by system time. Exercise 9.1: Matrix operationsCalculate A + A, AA’, A’A and AB. Write a function that computes A(B − λI) for any λ. Code12345678910111213A_add_A = A + AA_mul_AT = numpy.matmul(A, A.transpose())AT_mul_A = numpy.matmul(A.transpose(), A)A_mul_B = numpy.matmul(A, B)print("---------- A+A -----------\n"+str(A_add_A))print("---------- AA' -----------\n"+str(A_mul_AT))print("---------- A'A -----------\n"+str(AT_mul_A))print("---------- AB ------------\n"+str(A_mul_B))def E_9_1(A, B, N): return numpy.matmul(A, B-N*numpy.eye([len(B), len(B)]))print("--------- E_9_1 ----------\n"+str(E_9_1(A, B, 3))) Result12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970---------- A+A -----------[[-0.99675071 -0.6495676 1.01357349 ..., -2.5407868 1.53207886 0.0751089 ] [-0.06925787 -0.42836986 2.4504027 ..., 1.69732532 0.80316565 -1.30803462] [ 2.25823479 0.98806253 -0.5739649 ..., 1.22649302 1.46312748 -3.16395929] ..., [-1.37475203 -1.79483411 0.25941863 ..., -1.64123271 0.19708262 2.00484962] [-0.62106414 -0.1070131 -3.0257811 ..., -4.53252983 1.58481669 -1.47097894] [ 0.59292533 0.8860513 2.69104758 ..., 0.25052273 -1.49885506 -2.80481829]]---------- AA' -----------[[ 524.50900633 -23.41422424 -8.4109328 ..., -17.09509132 -36.58226516 22.36854305] [ -23.41422424 474.25665538 -20.03371708 ..., -15.65752606 14.95693007 -6.58265367] [ -8.4109328 -20.03371708 534.41749229 ..., -10.27103728 19.68694583 30.70304678] ..., [ -17.09509132 -15.65752606 -10.27103728 ..., 440.6393497 -3.86846872 24.44312808] [ -36.58226516 14.95693007 19.68694583 ..., -3.86846872 460.44551208 -24.6430389 ] [ 22.36854305 -6.58265367 30.70304678 ..., 24.44312808 -24.6430389 533.38452907]]---------- A'A -----------[[ 207.71499004 -8.83528023 17.29332948 ..., 1.35094389 9.97232568 18.87072786] [ -8.83528023 151.22418385 18.14374619 ..., 0.76927965 4.16070767 -16.40379885] [ 17.29332948 18.14374619 205.02249127 ..., -8.18432486 -9.26707911 2.07063859] ..., [ 1.35094389 0.76927965 -8.18432486 ..., 208.97270412 -5.71621365 8.51065013] [ 9.97232568 4.16070767 -9.26707911 ..., -5.71621365 174.85487874 -6.98119382] [ 18.87072786 -16.40379885 2.07063859 ..., 8.51065013 -6.98119382 186.52479968]]---------- AB ------------[[-14.87853525 8.70049763 0.66427479 ..., -40.15235048 38.96819378 36.98761191] [ 8.62765483 -38.65652814 1.54867974 ..., 51.0022929 2.29161362 2.36645638] [-28.67531663 -23.03994764 5.9337154 ..., -1.57998333 35.43202865 -1.02604062] ..., [ 21.1088727 -24.70137887 2.29477385 ..., 20.56806809 -33.32895855 -10.71314031] [ 16.33190225 -17.93547546 -9.57141851 ..., -40.75340698 65.49378203 -19.09691261] [-29.11460503 -43.80853239 35.2469557 ..., 15.52438326 20.15859321 -22.71350542]]--------- E_9_1 ----------[[-13.38340918 9.67484904 -0.85608544 ..., -36.34117028 36.67007549 36.87494856] [ 8.73154164 -38.01397334 -2.12692431 ..., 48.45630492 1.08686515 4.32850831] [-32.06266882 -24.52204143 6.79466275 ..., -3.41972285 33.23733743 3.71989831] ..., [ 23.17100075 -22.0091277 1.90564591 ..., 23.02991715 -33.62458247 -13.72041474] [ 17.26349845 -17.77495581 -5.03274686 ..., -33.95461223 63.116557 -16.89044419] [-30.00399303 -45.13760934 31.21038433 ..., 15.14859916 22.40687581 -18.50627799]] Knowledge matmul() to calculate the mul of 2 matrics. eye(k) to calculate a diagonal matrix, k*k transpose() to return matrix’s Inverse matrix Exercise 9.2: Solving a linear systemGenerate a vector b with m entries and solve Bx = b Code1234b = numpy.random.normal(size=m)x = numpy.linalg.solve(B, b)print("--------- E_9_2 ----------\n"+str(x)) Result12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485--------- E_9_2 ----------[ 0.77346147 -0.80520425 -0.35482528 -0.56178735 -0.21607332 0.09578284 0.45176672 -0.349336 -0.07061673 -0.67937045 0.77608967 0.02769846 -0.00266615 -0.78878366 0.32858871 -0.22730774 0.46410093 0.08025457 -0.39018536 0.31449226 -0.15399999 -0.90204851 0.36424562 0.61096627 0.33907227 -0.78779662 -0.48162797 -0.64274742 0.12995262 0.99430534 -0.14856798 -1.15273747 0.09436944 0.40647302 0.65276383 -0.10382041 0.41243053 -0.29856156 0.63452485 -0.22499859 -0.30249207 -0.14497932 0.85522387 0.21110914 -0.23258855 -0.9897657 -0.31338026 -0.26002534 0.924013 -0.47043625 -0.45807153 -0.75775808 1.12480813 0.30321897 -0.29125859 -0.33289894 -0.64971968 0.50094724 0.36235713 -0.00269059 -0.15268968 -0.01259865 0.41392597 -0.83904654 -0.47292343 -0.18366766 0.15149868 1.16077591 -0.53859254 -0.98168055 -0.42284948 1.11918415 0.47384948 -0.21576477 -0.57785042 0.16373249 0.58937659 0.05069881 -0.60646457 -0.07515867 -0.25892701 0.60705024 -0.40504958 -0.41706291 0.02971281 0.69272723 -0.27455502 -0.26949703 -0.88870169 -0.1796936 0.3022728 0.32450019 -0.40309466 -0.28997186 0.28757543 0.83201615 0.18273413 0.19503945 -0.83802164 0.13698447 0.35706851 0.41057604 0.15437131 -0.12593118 -0.78262502 0.46311827 0.18733747 -0.12280002 -0.17000113 0.72736406 0.04638688 -0.0446584 -0.3740762 0.10985653 0.55118338 0.58155485 -0.31415809 0.02940531 0.26057846 1.10319678 0.32003339 -0.66484382 -0.24373552 0.85396941 0.25111252 -0.07437428 -0.42373725 -0.00220312 0.49085239 0.58744762 -0.73623476 0.00606373 0.30887715 0.40351642 0.24192468 -0.60608552 -0.06592915 0.57245086 1.18607234 -0.05819671 -0.63773722 -0.8275492 0.47117888 0.8240523 0.09995859 -1.1189529 -0.68472816 0.08958122 0.94135285 -0.21713449 -0.22415887 -0.73924185 -0.00985684 0.53434199 -0.22782094 -0.00677473 0.18406202 0.25589949 0.02174665 -0.47176496 -1.00158691 0.29509947 0.46664914 -0.65511163 -0.15173256 -0.22610517 0.71416397 0.42033317 -0.8626862 -0.95496022 0.41023983 0.69597171 0.79422447 -0.10630244 -0.90460346 0.04098153 0.52159034 0.65757128 -0.40015286 -0.10895269 -0.21034717 0.56477992 0.35828024 0.08569485 -0.29118951 0.26209546 -0.08259761 -0.49767682 0.00403437 0.15095307 0.35145479 0.5900982 0.02764191 -0.2800535 0.37674186 0.24215259 0.19028278 -0.22832022 -0.58452005 0.23195453 1.01708531 0.21018793 -0.07069491 -0.20749496 -0.30999703 0.98823655 0.88781881 0.01026305 -0.31819752 -0.45149265 0.23417009 0.20983107 0.22389019 -0.00310436 0.33739053 -0.02782074 0.05340627 -0.24885277 0.25400433 0.64797729 -0.03559467 -0.05009246 -0.08380507 0.36138515 0.5550696 0.28391703 -0.39964763 0.33188527 -0.15623489 0.53671244 -0.07852636 -0.33260849 -0.26049435 0.16521133 -0.29556138 -0.14604016 0.1189506 -0.72699557 0.75795078 -0.72868493 0.60271873 -0.62082569 0.20283552 0.06472603 0.31866239 -0.90097767 -0.15603714 -0.53582783 0.88605567 -0.36223599 -0.59827917 -1.29951569 0.1108652 0.66520771 0.01635112 -0.47215453 -1.24440155 -0.08236616 0.77307018 0.08110942 0.20703049 -1.09960752 0.53298015 -0.1027147 0.57313429 -0.26114314 0.36161462 -0.63713623 0.24713223 -0.12035843 0.11065281 0.09846977 -0.43356553 -0.02745542 -0.03750936 0.15417482 0.02681122 0.35293284 -0.22082268 0.52545969 -0.52711138 0.94215319 0.59478862 0.44168817 -0.27060941 -0.43870625 0.34660181 1.0296679 0.96253921 0.09362239 0.12398285 -0.32504824 0.59667371 -0.29713152 -0.15533326 -0.08547569 0.24128572 -0.25817327 0.12638511 -0.32930891 0.34818106 0.62209695 0.00579373 -0.09340648 0.29222168 0.50828812 0.03484351 0.3983519 -0.65951852 0.07763202 0.09992687 0.31966399 0.19685432 -0.37118144 -0.13390334 0.54808429 0.50920353 -0.074975 -0.76687343 -0.43923484 -0.09119431 0.32772465 0.34325338 0.01731712 -0.28073798 0.39537496 0.09365181 -0.24057869 -0.5238085 -0.3035102 0.53520429 0.94732342 -0.40593518 -0.37112931 -0.0610225 0.26211594 0.51096725 -0.74657876 -0.4668039 0.34383364 0.65990638 -0.67455365 -0.20302455 -0.51223175 0.20865335 0.31091778 -0.3855612 -0.58707168 0.21290637 0.28386365 0.25445908 -0.42757652 -0.34554999 0.57824806 0.56947678 -0.44043856 -0.59497373 -0.19046726 0.78359797 0.125395 0.01909045 -1.25379069 -0.09729798 0.52626197 0.78733424 -0.54835847 -0.47638112 -0.07003016 0.55939806 1.16409273 -0.0810496 -0.18461299 0.41337285 0.72340257 0.47537153 0.11145316 -0.41716581 0.15447172 0.87950718 0.32799822 -0.72525093 -0.25424443 -0.33243891 0.89624186 -0.24327463 -0.377505 -0.01318703 1.15073861 0.50827694 0.14629782 -0.60745337 0.35594258 0.77265696 0.51980829 -0.43604754 0.19361863 0.0974694 0.12374675 0.22393652 -0.25111504 -0.16791473 0.66888136 0.08905014 -0.24185122 -0.82934214 0.17298365 0.32383379 0.38730725 -0.55691312 -0.14960641 -0.3161664 1.00423863 -0.13530144 0.2758329 -0.59409022 -0.72711962 0.18561096 0.29493483 -0.49462417 -0.02535275 -0.32179269 0.63802358 0.06450911 -0.36244535 -0.55088169 0.47010579 -0.03932424 -0.05139748 -0.72489824 0.43677258 0.85363747 0.59513256 -1.1427693 -0.75490234 -0.05380666 0.84642801 0.97061214 -0.82256622 -1.12268162 -0.11974293 0.25058075 -0.14730279 -0.41490229 0.47094733 0.0695535 -0.06111872 -0.00325791 -0.69918284 0.97462969 0.10417971 -0.06695869 -1.23309132 -0.17049135 0.64043296 0.82727541 -0.20828416 -0.59323465 -0.65802288 0.32621394 0.5368197 0.37921229 -1.08605397 0.16858299 0.03444726 0.11315069 0.05051093 0.03860219 -0.35531796 0.3553949 0.39874088 -0.52344943 -0.13202249 0.91263459 0.32986441 0.26566883 -0.62952324 -0.54520924 -0.43928257 1.0950506 0.1665704 -1.02249691 -0.05817481 -0.30783025 0.09503854 0.06272448 -0.35042346 0.06067587 0.08451991 0.3850205 -0.77288649 0.17066585 0.10336318 0.37866533 -0.63292289 -0.15179168 0.06741788 0.41384271 -0.29224392 0.39719698 -1.22197233] Knowledge numpy.linalg.solve(a, b) to calculate the result of ax = b Exercise 9.3: NormsCompute the Frobenius norm of A: |A|F and the infinity norm of B: |B|∞. Also find the largest and smallest singular values of B. Code12345678910A_FN = numpy.linalg.norm(A, 'fro')B_IN = numpy.linalg.norm(B, numpy.inf)print("---------- A_FN ------------\n"+str(A_FN))print("---------- B_IN ------------\n"+str(B_IN))U, sigma, V = numpy.linalg.svd(B)B_max_singular = numpy.max(sigma)B_min_singular = numpy.min(sigma)print("---------- B_max_singular ------------\n"+str(B_max_singular))print("---------- B_min_singular ------------\n"+str(B_min_singular)) Result12345678---------- A_FN ------------316.813378033---------- B_IN ------------387.19726512---------- B_max_singular ------------51.6474766426---------- B_min_singular ------------0.0562452006537 Knowledge 矩阵范数：norm, numpy.linalg.norm() 奇异值分解：singular values， numpy.linalg.svd() Exercise 9.4: Power iterationGenerate a matrix Z, n × n, with Gaussian entries, and use the power iteration to find the largest eigenvalue and corresponding eigenvector of Z. How many iterations are needed till convergence? Optional: use the time.clock() method to compare computation time when varying n. Code1234567891011121314151617181920212223242526272829import timeZ = numpy.random.normal(size=[n, n])def power_iteration_eigenvalue( X, err=0.01): x = numpy.random.normal(size=len(X)).transpose() step = numpy.inf times = 0 time_begin = time.clock() while step &gt; err: old = numpy.max(x) x = x/old x = numpy.matmul(X, x) new = numpy.max(x) step = abs(old-new) times += 1 # print("step "+str(times)+" : "+str(new)) time_end = time.clock() return x, new, times, time_end-time_begin[eigenvector, eigenvalue, times, running_time] = power_iteration_eigenvalue(Z)print("------------ E_9_4 ----------------")print("eigenvector: "+str(eigenvector))print(" eigenvalue: "+str(eigenvalue))print(" step count: "+str(times))print(" time used: "+str(running_time)) Result123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354------------ E_9_4 ----------------eigenvector: [ 6.19366521e+00 -7.19111305e+00 7.47822455e+00 1.76596816e+00 -1.22108278e+01 -6.68997718e+00 -1.07959431e+01 7.38413171e+00 9.60996846e+00 -3.39415864e+00 -1.23836889e+01 1.60311426e+01 -3.55845284e-01 -1.69182976e+01 6.50582275e+00 -3.93769884e+00 7.23395058e+00 -6.30992140e+00 3.77506490e+00 -3.23313667e+00 6.64974007e+00 -7.24150321e+00 9.88020162e+00 2.08854412e-03 3.07409841e+00 3.42129651e+00 -5.92382223e+00 -1.35043015e+00 -1.40770229e+00 1.24531978e+01 -6.32025548e+00 -1.26441627e+01 3.26831772e-01 -1.42739520e+00 1.32925887e+00 1.06598272e+01 -8.48197449e+00 4.82646327e+00 3.67864359e+00 -2.92456117e+00 1.49065221e+01 -3.89251672e+00 1.24128342e+01 1.27677631e+01 -1.11263113e+01 -1.46350312e+01 9.36651121e+00 -3.84124488e-01 -5.67795245e+00 -8.75638867e+00 6.02814460e+00 -9.83530958e-01 6.50873016e+00 9.18944025e+00 -1.08015910e+01 -2.27073094e+00 2.05116066e+00 9.74180888e+00 4.34640807e+00 -1.45355560e+00 1.72229371e+00 1.60129994e+00 -9.49922896e+00 -9.26528224e+00 1.41245323e+01 1.29324148e+00 1.15170129e+01 -2.78286401e+00 -2.41103992e+00 -6.04664999e+00 1.60510520e+01 9.06866735e+00 -2.39722406e+00 -7.74249726e+00 -6.22329381e+00 5.66999289e+00 7.07244637e-01 -1.42750525e+01 1.00944549e+01 -1.56414851e-01 -6.77685962e+00 -1.31324847e+00 1.40962962e+01 -2.82314517e+00 1.15847925e+00 -1.45499963e+01 -1.47587123e+00 -5.45102517e+00 2.07919993e+00 1.48515566e+00 -3.34405736e+00 -4.93831256e-01 3.52542969e+00 -4.49030531e+00 -4.14344570e+00 -6.73085059e+00 -1.96366164e+00 -4.73358636e+00 -1.42491876e+01 7.14478669e-01 -4.03345293e+00 -8.64438839e-01 -1.91710524e+00 4.02300501e-01 -3.12336156e+00 3.25908960e+00 8.73984942e+00 1.80387754e+00 5.37126471e-01 2.33427637e-01 7.20753102e+00 8.38898454e+00 6.73706722e+00 2.25368920e+00 4.03456123e+00 -5.26635000e-01 -1.09389778e+01 -1.69632014e+01 -5.04630146e+00 2.99535217e+00 -4.97695971e+00 7.08832858e+00 -1.42509689e+00 5.44444010e-01 1.14700391e+00 -3.34913269e+00 -1.68841359e+00 -1.85218648e+00 6.17064696e+00 -1.17127043e+00 -7.25388347e+00 -2.70293145e+00 -8.28104371e+00 1.64055792e+00 4.94486141e+00 4.18690047e+00 -9.94856800e+00 -8.29269461e+00 5.81317629e+00 -1.31414167e+01 8.10423657e-01 -1.30089443e+01 -7.10088385e+00 -7.62918634e+00 5.14150493e+00 4.43537243e+00 -3.52960575e-01 -1.35215797e+00 -5.68239918e+00 -5.78998103e+00 -4.91632266e-01 -2.68038511e+00 -1.03668811e+01 5.49950249e+00 -2.26436209e+00 1.23865979e+01 6.14732355e+00 4.31623361e+00 -8.40648179e+00 -3.72063488e+00 2.01815136e+00 -5.14877954e-01 -1.16816147e+00 -2.24455122e+01 -5.57878300e+00 3.10970510e-01 1.29690655e+00 -1.69972653e+01 1.58677609e+01 -5.77551543e+00 -4.36274195e+00 -5.63981586e+00 -4.54383986e+00 -7.16379461e-01 -4.07212591e+00 -5.45036929e+00 -9.33501142e+00 -1.46760018e+01 -4.31132630e+00 1.16448053e+01 6.21216923e+00 -6.78022246e+00 4.13536082e+00 3.69218241e+00 1.97466803e+00 -1.08666389e+00 8.80475201e+00 2.46159249e+00 2.21402112e+00 -2.46765512e+00 3.57973968e+00 -1.11716056e-01 -8.24346370e+00 -2.90508233e+00 4.13721878e+00 -4.10881873e+00 5.15073997e+00 -1.22542384e+01 3.96149388e+00 -1.13627510e+01] eigenvalue: 16.0510519646 step count: 68 time used: 0.007216 Knowledge eigenvalue: 特征值 幂迭代法：x(k) = x(k-1)*A Exercise 9.5: Singular valuesGenerate an n × n matrix, denoted by C, where each entry is 1 with probability p and 0 otherwise. Usethe linear algebra library of Scipy to compute the singular values of C. What can you say about therelationship between n, p and the largest singular value? Code12345678p = 0.1print("-------------- E_9_5 ------------------")while p&lt;1: C = numpy.random.binomial(1, p, [n, n]) U, singular_value, V = numpy.linalg.svd(C) max_singular = numpy.max(singular_value) print("n= "+str(n)+" p= "+str(p)+" max_singular= "+ str(max_singular)) p += 0.1 Result1234567891011-------------- E_9_5 ------------------n= 200 p= 0.1 max_singular= 20.6567657213n= 200 p= 0.2 max_singular= 40.4920520455n= 200 p= 0.3 max_singular= 60.6782510601n= 200 p= 0.4 max_singular= 81.0362830637n= 200 p= 0.5 max_singular= 101.14764207n= 200 p= 0.6 max_singular= 120.373897161n= 200 p= 0.7 max_singular= 139.768077408n= 200 p= 0.8 max_singular= 160.37471516n= 200 p= 0.9 max_singular= 179.191890776n= 200 p= 1.0 max_singular= 200.0 Knowledge random.binomial(n, p, size), n is 0~n, p is probability, size is size we can find that max_singular = n * p Exercise 9.6: Nearest neighborWrite a function that takes a value z and an array A and finds the element in A that is closest to z. Thefunction should return the closest value, not index. Hint: Use the built-in functionality of Numpy rather than writing code to find this value manually. Inparticular, use brackets and argmin. Code123456789def closest( X, z): ind = numpy.argmin(numpy.abs(X - z * numpy.ones((len(X), len(X[0]))))) return X[ind//len(X[0])][ind%len(X[0])]print("-------------- Closest ---------------")z = -1while z &lt;= 1: print("z= "+str(z)+" closest= "+str(closest(A, z))) z += 0.1 Result12345678910111213141516171819202122-------------- Closest ---------------z= -1 closest= -1.00000868018z= -0.9 closest= -0.899991177575z= -0.8 closest= -0.799982994952z= -0.7 closest= -0.699995902891z= -0.6 closest= -0.59999964816z= -0.5 closest= -0.499995702358z= -0.4 closest= -0.399997886746z= -0.3 closest= -0.299999122356z= -0.2 closest= -0.200002337307z= -0.1 closest= -0.0999872558528z= -1.38777878078e-16 closest= -1.45838021333e-05z= 0.1 closest= 0.10001924864z= 0.2 closest= 0.200009578588z= 0.3 closest= 0.30001507798z= 0.4 closest= 0.399992197442z= 0.5 closest= 0.499998597393z= 0.6 closest= 0.599983955592z= 0.7 closest= 0.700043443047z= 0.8 closest= 0.800006259776z= 0.9 closest= 0.900013425609z= 1.0 closest= 1.00000424317 Knowledge argmin(X) to return X’s minimum’s index Reference]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[星球的公转与自转]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%98%9F%E7%90%83%E7%9A%84%E5%85%AC%E8%BD%AC%E4%B8%8E%E8%87%AA%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[星球公转与自转 更新：将公转矩阵与摄像机矩阵分离，公用变换（摄像机、透视）与各个物体的单独变换分离，使代码更符合逻辑。 环境说明 开发环境：Linux 运行环境：Linux 运行方式： 打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./planet_rotation 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 附有运行成功的demo，可以作为参考 使用库：GLFW、GLEW、GLM 运行结果 ESC：退出程序 D：按下后逆时针自转 shift+D：顺时针自转 Y：按下后逆时针公转 shift+Y：顺时针公转 方向键：旋转观察视角 公转与自转： 改变旋转方向： 更改观察视角 实现过程 生成球体： 生成顶点：遍历每个纬度、经度，计算纬度、经度映射到球体上的坐标 生成球面三角：在北极点与南极点处，与相邻纬度生成三角；在其余纬度上，与相邻纬度生成四边形（即两个三角） 生成缓冲区：将生成的球体顶点与顶点索引绑定至缓冲区，VAO分别为SUM和PLANET，代表大球（太阳）及小球（行星） 生成着色器 绘制：View作为摄像机视角，Projection为透视矩阵，这二者为全局公用。 按处理对象，分为两种矩阵——公共矩阵及单个模型的矩阵； self_trans设为小球的旋转矩阵，管理自转； position_trans设为小球的轨道初始坐标 public_trans设为小球的坐标矩阵，管理公转； 按照mvp = Projection * View * public_trans * position_trans * self_trans;顺序管理小球——先自转，再移动，后以透视视角形变。 分别绑定两个缓冲区，分别绘制两个星球。 交互：设置键盘事件，管理自转与公转的旋转角度 ESC：退出程序 D：按下后逆时针自转 shift+D：顺时针自转 Y：按下后逆时针公转 shift+Y：顺时针公转 方向键：旋转观察视角 知识点 多个物体绘制: 当多个物体需要绘制时，每个物体有自己的顶点缓冲区、顶点索引缓冲区，因此为每一个物体设置一个顶点数组（VAO），此后每次需要此物体时，直接绑定该顶点数组，同时绑定内部的数据格式。 球体生成： 遍历球体的每个纬度、经度，通过三角函数运算得到对应经纬度的正交右手系坐标: 12345678910111213for (unsigned int i=0; i &lt;= HorSlide; i++)&#123; float hor_angle = hor_step * i; float z_cur = radius * cos(hor_angle); //z原点坐标 float r_cur = radius * sin(hor_angle); //纬度平面半径 for (unsigned int j=0; j &lt;= VerSlide; j++)&#123; float ver_angle = j*ver_step; float x_cur = r_cur * cos(ver_angle); //顶点入vector vects.push_back(x_cur+x); vects.push_back(y_cur+y); vects.push_back(z_cur+z);... ... 并对每个相邻的纬度生成球面三角: 12345678910111213141516171819202122232425262728//插入球面三角形顶点索引if (i &gt; 0 &amp;&amp; j &gt; 0)&#123; //若以自我为一个四边形的右下角，其绘制曲面三角的点： unsigned int ru = index - VerSlide; unsigned int lu = index - VerSlide - 1; unsigned int ld = index -1; unsigned int rd = index; //上或下一圈为一个点，添加的为三角形 if (i == 1)&#123; inds.push_back(ru); inds.push_back(ld); inds.push_back(rd); &#125; else if (i == HorSlide)&#123; inds.push_back(ru); inds.push_back(lu); inds.push_back(rd); &#125; //四边行情况——添加两个三角形 else&#123; inds.push_back(ru); inds.push_back(ld); inds.push_back(rd); inds.push_back(ru); inds.push_back(lu); inds.push_back(ld); &#125;&#125; 旋转变换： 公转：通过旋转摄像机函数，得到公转的效果，同时反向等速旋转大球，使其独立于公转不旋转： 12View = glm::rotate(View, glm::radians(public_rotate), glm::vec3(0, 0, 1.0f)); //旋转视角以公转model = glm::rotate(model, glm::radians(-public_rotate), glm::vec3(0, 0, 1.0f)); //旋转大球以让大球看起来静止 自转：在绘制完大球后，绑定小球缓冲区，并计算自传的变换矩阵。其中，最关键的是 绕任意轴旋转: 将小球移动至原点 在原点对小球进行旋转 将小球移动回自己的轨迹 生成变换矩阵，绘制。123456789101112131415161718glBindVertexArray(PLANET);planet_self = planet_self + self_rotate;if (planet_self &gt; 360) planet_self -= 360;else if (planet_self &lt; 0) planet_self += 360;planet_public = (planet_public + public_rotate);if (planet_public &gt; 360) planet_public -= 360;else if (planet_public &lt; 0) planet_public += 360;glm::mat4 public_trans = glm::rotate(model, glm::radians(planet_public), glm::vec3(0, 0, 1));glm::mat4 position_trans = glm::translate(model, position);glm::mat4 self_trans = glm::rotate(model, glm::radians(planet_self), glm::vec3(0, 0, 1));mvp = Projection * View * public_trans * position_trans * self_trans;glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(mvp));glDrawElements(GL_LINE_STRIP, indsP.size(), GL_UNSIGNED_INT, (void*)0); // we use index buffer, so set it to null. 按键交互：转自 1234567891011key include/GLFW/glfw3.h 中定义的 GLFW_KEY_* 包含一些按键的ASCII码scancdeaction 按键动作GLFW_RELEASE 松开GLFW_PRESS 按下GLFW_REPEAT 重复，一直按着mods 按键模式GLFW_MOD_SHIFT 按下Shift键GLFW_MOD_CONTROL 按下Ctrl键GLFW_MOD_ALT 按下Alt键GLFW_MOD_SUPER 实验过程 最后一个顶点总在原点——总有个“小尾巴”与原点相连 index算错，整体向后偏移一个，因此最后一个index对应的点在原点，更改后： 生成圆时ｚ坐标偏移出错:输出坐标发现，z的坐标在不断叠加： 12345678910-8.74228e-08 0 0-8.63465e-08 -1.36759e-08 1-8.3144e-08 -2.70151e-08 2-7.78943e-08 -3.96891e-08 3-7.07265e-08 -5.13858e-08 4-6.18172e-08 -6.18172e-08 5-5.13858e-08 -7.07265e-08 6-3.96891e-08 -7.78943e-08 7-2.70151e-08 -8.3144e-08 8-1.36759e-08 -8.63465e-08 9 原来是z坐标没有在纬度平面上循环时重置……12345678//根据原点坐标，进行平移x_cur += x;y_cur += y;z_cur += z;//顶点入vector vects.push_back(x_cur);vects.push_back(y_cur);vects.push_back(z_cur); 改为以下即可：123vects.push_back(x_cur+x);vects.push_back(y_cur+y);vects.push_back(z_cur+z); 源代码参考资料球体生成 按键]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenGL 旋转彩色立方体]]></title>
    <url>%2F2018%2F05%2F10%2FOpenGL-%E6%97%8B%E8%BD%AC%E5%BD%A9%E8%89%B2%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[彩色旋转立方体环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/Cubic文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./cubic 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM 知识点 矩阵变换 矩阵的变换分为三种：放缩、旋转、平移，三者顺序不应混乱，用矩阵乘法表示： 1glm::mat4 mvp = Projection * View * model; 在本次实验中，使用的是透视视角，即近大远小，使用projection函数可以生成透视变换视角，属于放缩变换： 1glm::mat4 Projection = glm::perspective(glm::radians(90.0f), (float) width / (float)height, 0.1f, 100.0f); 为了让矩阵旋转，我们首先预设摄像机位置： 12345glm::mat4 View = glm::lookAt( glm::vec3(4,3,3), // Camera is at (4,3,3), in World Space glm::vec3(0,0,0), // and looks at the origin glm::vec3(0,1,0) // Head is up (set to 0,-1,0 to look upside-down)); 再于每次渲染改变角度（旋转矩阵）： 1View = glm::rotate(View, glm::radians(1.0f), glm::vec3(-1.0f, -1.0f, 1.0f)); 着色器： 着色器分类：本次实验中用到像素着色器与顶点着色器，顶点着色器用于将外部的顶点信息打包给其他着色器绘制，像素着色器用于染色。 着色器使用GLSL语言进行编写，并在C++中用字符串形式进行输入： 1234567891011//顶点着色器 const GLchar* vertexShaderSource="#version 330 core\n" "layout (location=0) in vec3 aPos;\n" "layout (location=1) in vec3 vertexColor;\n" "out vec3 fragmentColor;\n" "uniform mat4 transform;\n" "void main()\n" "&#123;\n" "gl_Position = transform * vec4(aPos, 1.0);\n" "fragmentColor = vertexColor;\n" "&#125;\0"; 着色器的编译与测试： 1234567891011int vertexShader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader);GLint success; GLchar infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; 着色器链接： 123456789int shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; 着色器参数属性： 123glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 将变换矩阵传入着色器的uniform变量中： 12unsigned int transformLoc = glGetUniformLocation(shaderProgram, "transform");glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(mvp)); 深度测试：若不开启深度测试，会导致着色器无法判断覆盖信息，深度测试的用途是用于舍弃被遮盖住的图像，使其更加真实： 12glEnable(GL_DEPTH_TEST);glDepthFunc(GL_LESS); 源码结果 注意事项 本环境中未配置glad，而使用glew，在代码开始时注意此初始化顺序： 123456789101112131415glfwInit();//初始化 // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, "The perspective projection", NULL, NULL); glfwMakeContextCurrent(window);//设置为当前窗口 // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); 否则会导致此错误： 1Segmentation fault (core dumped) 若提示./cubic command not found则先chmod u+x cubic 在未配置opengl环境的电脑上运行时可能缺少动态链接库，因此将动态链接库打包于项目文件中的dll文件夹，使用时需要用 1export LD_LIBRARY_PATH=xxx 增加动态链接库搜索位置，其中xxx为dll文件夹。 参考来源绘制旋转立方体 规范代码 透视教程 录屏转gif 动态库链接]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello OpenGL]]></title>
    <url>%2F2018%2F05%2F07%2FHello-OpenGL%2F</url>
    <content type="text"><![CDATA[VSCode + GLFW + GLEW 在ubuntu下的安装环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/HelloOpenGL文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./helloOpenGL 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM安装OpenGL（包括GLUT）：123sudo apt-get install build-essential libgl1-mesa-devsudo apt-get install freeglut3-devsudo apt-get install libglew-dev libsdl2-dev ibsdl2-image-dev libglm-dev libfreetype6-dev GLFW： 去官网下载源码 编译安装： 安装cmake: sudo apt-get install cmake 解压刚刚下载的源码: sudo unzip xxx.zip -d glfw，其中xxx为你刚刚下载的压缩包名 进入解压后的GLFW根目录（含有include、CMake的那个），进行安装: 123sudo cmake .sudo makesudo make install GLEW： 查看glew：sudo apt-cache search glew 将显示的内容用sudo apt-get install xxx下载下来，其中xxx为要下载的内容 编译1g++ -o helloOpenGL helloOpenGL.cpp -lGL -lGLU -lglut -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lpthread -lGLEW -ldl 实例源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;using namespace std;// Is called whenever a key is pressed/released via GLFW void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE); &#125; int main(void)&#123; GLFWwindow* window; /* Initialize the library */ if (!glfwInit()) return -1; /* Create a windowed mode window and its OpenGL context */ window = glfwCreateWindow(800, 600, "The First Opengl Program", NULL, NULL); if (!window) &#123; glfwTerminate(); return -1; &#125; // Set the required callback functions 设置事件回调函数 glfwSetKeyCallback(window, key_callback); /* Make the window's context current */ glfwMakeContextCurrent(window); /* Loop until the user closes the window */ while (!glfwWindowShouldClose(window)) &#123; /* Draw a triangle */ glBegin(GL_QUAD_STRIP); glVertex3f(0.5, 0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(-0.5, 0.5, 0.0); glVertex3f(-0.5, -0.5, 0.0); glEnd(); /* Swap front and back buffers */ glfwSwapBuffers(window); /* Poll for and process events */ glfwPollEvents(); &#125; glfwTerminate(); return 0;&#125; 效果 注意事项 GLEW应该在GLFW、GLUT等之前include。 要加上-ldl，否则会出现错误： 12/usr/bin/x86_64-linux-gnu-ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol 'dlclose@@GLIBC_2.2.5'//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line 由于很多教程基于GLUT，又有很多教程基于GLFW、GLEW，因此编译连接了大部分可能用到的库 若不调用GLEW，很有可能造成shader的许多问题 参考来源：关于GLEW的错误 GLFW的安装 GLEW的安装 OpenGL下载安装+GLEW的include顺序问题 OpenGL环境配置 渲染器 绘制demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业08 LeetCode #213 #120]]></title>
    <url>%2F2018%2F04%2F29%2FPython%E4%BD%9C%E4%B8%9A08-LeetCode-213-120%2F</url>
    <content type="text"><![CDATA[213 House Robber II原题After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 题意分析给出一个循环数列（即第一个数与最后一个数相邻），不允许取相邻的数字，求取出数字和的最大值。 题目思路用动态规划。首先由于是循环数列，因此第一个与最后一个不能同时取到（但可以同时不取到），因此我们分别删除第一个和最后一个进行计算，消除循环队列的影响。由于不能取到两个相邻的数字，因此可以得到状态转移方程： F(k) = max(F(k-2)+num[k], F(k-1)) 补充边界： F(0) = num[0] F(1) = max(num[0], num(1)) 注意，上述的num数列已经是剔除第一或最后一个数字的数列。 代码（python）123456789101112131415161718192021class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums)==0: return 0 if len(nums)==1: return nums[0] tmp = nums.pop(0) last, now = 0, 0 for i in nums: last, now = now, max(last+i, now) r1 = now nums.insert(0, tmp) nums.pop() last, now = 0, 0 for i in nums: last, now = now, max(last+i, now) return max(r1, now) 结果 120 Triangle原题Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题意分析在给出的数字三角形中，从顶向下找出一条数字和最小的路径，计算其最小数字和。 题目思路动态规划，维护一个列表储存上一层（较长的一层，在本题中是下一层）选择各个节点的结果，给出下列状态转移方程（i为行，j为列）： F(0,j) = list(0,j) F(i,j) = max(F(i-1, j)+list(i,j), F(i-1, j+1)+list(i,j)) 由于仅需要上一层第j个和第j+1的信息，因此可以维持一个一维列表即可满足——每次从左至右更新放至列表的第j位。 代码（python）1234567891011class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ res = triangle.pop() for l in reversed(triangle): for i in range(len(l)): res[i] = min(res[i]+l[i], res[i+1]+l[i]) return res[0] 结果]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业06代码测试]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E4%BD%9C%E4%B8%9A06%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Description (test)Select from exercise 11-1 to 11-3 Code (test)11-1in city_functions.py:12def city_functions( city, country): return city+', '+country in test module:12345678910111213# 11-1 城市和国家 ：编写一个函数，它接受两个形参：一个城市名和一个国家名。这个函数返回一个格式为City, Country 的字符串，# 如Santiago, Chile 。将这个函数存储在一个名为city_functions.py的模块中。创建一个名为test_cities.py的程序，对刚编写的函# 数进行测试（别忘了，你需要导入模块unittest 以及要测试的函数）。编写一个名为test_city_country() 的方法，核实使用类似于# 'santiago' 和'chile' 这样的值来调用前述函数时，得到的字符串是正确的。运行test_cities.py ，确认测试test_city_country() 通过了。import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') result:12345678Testing started at 13:15 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --path D:/pyproject/homework1/11-1.pyRan 1 test in 0.001sOKLaunching unittests with arguments python -m unittest D:/pyproject/homework1/11-1.py in D:\pyproject\homework1 11-2 修改前面的函数，使其包含第三个必不可少的形参population ，并返回一个格式为City, Country - population xxx 的字符串，如Santiago, Chile - population 5000000 。运行test_cities.py，确认测试test_city_country() 未通过。 in city_functions.py:12def city_functions( city, country, population): return city + ', ' + country + ' - population ' + str(population) in test module:12345678import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') result:123456789101112131415161718192021Testing started at 13:25 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --target 11-2.CityCountryTestCase.test_city_functionsLaunching unittests with arguments python -m unittest 11-2.CityCountryTestCase.test_city_functions in D:\pyproject\homework1Ran 1 test in 0.004sFAILED (errors=1)ErrorTraceback (most recent call last): File "C:\Users\lenovo\AppData\Local\Programs\Python\Python36-32\lib\unittest\case.py", line 59, in testPartExecutor yield File "C:\Users\lenovo\AppData\Local\Programs\Python\Python36-32\lib\unittest\case.py", line 601, in run testMethod() File "D:\pyproject\homework1\11-2.py", line 12, in test_city_functions res = city_functions('Santiago', 'Chile')TypeError: city_functions() missing 1 required positional argument: 'population'Process finished with exit code 1 修改上述函数，将形参population 设置为可选的。再次运行test_cities.py，确认测试test_city_country() 又通过了。再编写一个名为test_city_country_population() 的测试，核实可以使用类似于&#39;santiago&#39; 、&#39;chile&#39; 和&#39;population=5000000&#39; 这样的值来调用这个函数。再次运行test_cities.py，确认测试test_city_country_population() 通过了。 in city_functions.py:12345def city_functions( city, country, population=-1): if population == -1: return city + ', ' + country else: return city + ', ' + country + ' - population ' + str(population) in test module:123456789101112import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') def test_city_functions_population(self): res = city_functions('Santiago', 'Chile', 500000) self.assertEqual(res, 'Santiago, Chile - population 500000') result:12345678910Testing started at 13:34 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --path D:/pyproject/homework1/11-2.pyLaunching unittests with arguments python -m unittest D:/pyproject/homework1/11-2.py in D:\pyproject\homework1Ran 2 tests in 0.001sOKProcess finished with exit code 0]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业05类&文件&异常]]></title>
    <url>%2F2018%2F04%2F08%2Fpython%E4%BD%9C%E4%B8%9A05%E7%B1%BB%E4%B8%8E%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Description (class)Select from exercise 9-1 to 9-15 Code (class)9-3123456789101112131415161718192021# 9-3 用户 ：创建一个名为User 的类，其中包含属性first_name 和last_name ，# 还有用户简介通常会存储的其他几个属性。在类User 中定义一个名# 为describe_user() 的方法，它打印用户信息摘要；再定义一个名为greet_user() 的方法，它向用户发出个性化的问候。# 创建多个表示不同用户的实例，并对每个实例都调用上述两个方法。class User(): def __init__(self, first_name, last_name): self.first_name = first_name.title() self.last_name = last_name.title() def describe_user(self): print(self.first_name+" "+self.last_name) def greet_user(self): print("Hello "+self.first_name+" "+self.last_name+"! ")users = [User("kate", "snow"), User("jone", "ossaki"), User("lin", "li")]for u in users: u.describe_user() u.greet_user() result:123456Kate SnowHello Kate Snow! Jone OssakiHello Jone Ossaki! Lin LiHello Lin Li! 9-5123456789101112131415161718192021222324class User(): def __init__(self, first_name, last_name): self.first_name = first_name.title() self.last_name = last_name.title() self.login_attempts = 0--snip-- def increment_login_attempts(self): self.login_attempts += 1 def reset_login_attempts(self): self.login_attempts = 0# 9-5 尝试登录次数 ：在为完成练习9-3而编写的User 类中，添加一个名为login_attempts 的属性。编写一个名为increment_login_attempts() 的方法，# 它将属性login_attempts 的值加1。再编写一个名为reset_login_attempts() 的方法，它将属性login_attempts 的值重置为0。# 根据User 类创建一个实例，再调用方法increment_login_attempts() 多次。打印属性login_attempts 的值，确认它被正确地递增；然后，调用方# 法reset_login_attempts() ，并再次打印属性login_attempts 的值，确认它被重置为0。test = User("King", "Kong")test.increment_login_attempts()test.increment_login_attempts()test.increment_login_attempts()print(test.login_attempts)test.reset_login_attempts()print(test.login_attempts) result:1230 9-71234567891011121314151617# 9-7 管理员 ：管理员是一种特殊的用户。编写一个名为Admin 的类，让它继承你为完成练习9-3或练习9-5而编写的User 类。# 添加一个名为privileges 的属性，用于存储一个由字符串（如"can add post" 、"can delete post" 、"can ban user" 等）# 组成的列表。编写一个名为show_privileges() 的方法，它显示管理员的权限。创建一个Admin 实例，并调用这个方法。class Admin(User): def __init__(self, first_name, last_name): super().__init__(first_name, last_name) self.privileges = ["can add post", "can delete post", "can ban user"] def show_privileges(self): for p in self.privileges: print(p)admin_test = Admin("Briiza", "Chen")admin_test.show_privileges() result:123can add postcan delete postcan ban user 9-111234567# 9-11 导入Admin 类 ：以为完成练习9-8而做的工作为基础，将User 、Privileges 和Admin 类存储在一个模块中，# 再创建一个文件，在其中创建一个Admin 实例并对其调用方法show_privileges() ，以确认一切都能正确地运行。import ninetest_import = nine.Admin("Buluce","Xiang")test_import.show_privileges() nine is the module define User and Adminresult:1234can add postcan delete postcan ban user Description (file)Select from exercise 10-1 to 10-16 Code (files)10-1123456789101112131415161718# 10-1 Python学习笔记 ：在文本编辑器中新建一个文件，写几句话来总结一下你至此学到的Python知识，# 其中每一行都以“In Python you can”打头。将这个文件命名为learning_python.txt，# 并将其存储到为完成本章练习而编写的程序所在的目录中。编写一个程序，它读取这个文件，并将你所写的内容打印三次：# 第一次打印时读取整个文件；第二次打印时遍历文件对象；第三次打印时将各行存储在一个列表中，再在with 代码块外打印它们。with open('learning_python.txt') as file_obj: content = file_obj.read() print(content)with open('learning_python.txt') as file_obj: for item in file_obj: print(item)with open('learning_python.txt') as file_obj: lines = file_obj.readlines()for line in lines: print(line) result:12345678910111213In Python you can code.In Python you can create a game.In Python you can use loop.In Python you can code.In Python you can create a game.In Python you can use loop.In Python you can code.In Python you can create a game.In Python you can use loop. 10-41234567891011121314# 10-4 访客名单 ：编写一个while 循环，提示用户输入其名字。用户输入其名字后，在屏幕上打印一句问候语，# 并将一条访问记录添加到文件guest_book.txt中。确保这个文件中的每条记录都独占一行。with open('guest_book.txt', 'a') as file_obj: while(1): name = input("Input your name(q to quit): ") if ( name == "q"): break print("Hello "+name+" !") file_obj.write(name+"\n")with open('guest_book.txt','r') as read_obj: context = read_obj.read() print(context) result:12345678910Input your name(q to quit): wangHello wang !Input your name(q to quit): heyHello hey !Input your name(q to quit): juneHello june !Input your name(q to quit): qwangheyjune 10-6 10-7123456789101112131415161718# 10-6 加法运算 ：提示用户提供数值输入时，常出现的一个问题是，用户提供的是文本而不是数字。在这种情况下，# 当你尝试将输入转换为整数时，将引发TypeError 异常。编写一个程序，提示用户输入两个数字，再将它们相加并打印结果。# 在用户输入的任何一个值不是数字时都捕获TypeError 异常，并打印一条友好的错误消息。对你编写的程序进行测试：先输入两个数字，# 再输入一些文本而不是数字。# 10-7 加法计算器 ：将你为完成练习10-6而编写的代码放在一个while 循环中，让用户犯错（输入的是文本而不是数字）后能够继续输入数字。while (1): a = input("Input 2 num, q to quit:") b = input() if (a=='q' or b=='q'): break try: aa = int(a) bb = int(b) except: print("Hey, error input, try again...") else: print(aa+bb) result:12345678Input 2 num, q to quit:abHey, error input, try again...Input 2 num, q to quit:235Input 2 num, q to quit:qf]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业04-输入&函数]]></title>
    <url>%2F2018%2F03%2F29%2Fpython%E4%BD%9C%E4%B8%9A04-%E8%BE%93%E5%85%A5-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description (input)Select from exercise 7-1 to 7-10 Code (input)7-31234567# 7-3 10的整数倍 ：让用户输入一个数字，并指出这个数字是否是10的整数倍。for i in range(1, 4): num = int(input("Enter a number: ")) if (num % 10 == 0): print("Yes") else: print("No") result:123456789Enter a number: 120YesEnter a number: 3NoEnter a number: fTraceback (most recent call last): File "D:/pyproject/homework1/7.py", line 3, in &lt;module&gt; num = int(input("Enter a number: "))ValueError: invalid literal for int() with base 10: 'f' 7-712345# 7-7 无限循环 ：编写一个没完没了的循环，并运行它（要结束该循环，可按Ctrl +C，也可关闭显示输出的窗口）。i = 0while(1): print(i) i = i+1; result:1234123... 7-1012345678910# 7-10 梦想的度假胜地 ：编写一个程序，调查用户梦想的度假胜地。使用类似于“If you could visit one place in the world,# where would you go?”的提示，并编写一个打印调查结果的代码块。cities = []for i in range(0, 10): where = input("If you could visit one place in the world, where would you go?") cities.append(where)for city in set(cities): print(city+": ") print(cities.count(city)) result:12345678910111213141516171819202122If you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?AmericaIf you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?TokyoIf you could visit one place in the world, where would you go?KyotoIf you could visit one place in the world, where would you go?TokyoIf you could visit one place in the world, where would you go?ShanghaiIf you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?Beside youIf you could visit one place in the world, where would you go?KyotoBeside you: 1Shanghai: 1Tokyo: 2Kyoto: 2HongKong: 3America: 1 Description (function)Select from exercise 8-1 to 8-16 Code (function)8-2123456# 8-2 喜欢的图书 ：编写一个名为favorite_book() 的函数，其中包含一个名为title 的形参。这个函数打印一条消息，# 如One of my favorite books is Alice in Wonderland 。调用这个函数，并将一本图书的名称作为实参传递给它。def favorite_book( title): print("One of my favorite books is "+title.title())favorite_book(input("Which book do you like best?")) result:12Which book do you like best?harry potterOne of my favorite books is Harry Potter 8-41234567891011# 8-3 T恤 ：编写一个名为make_shirt() 的函数，它接受一个尺码以及要印到T恤上的字样。这个函数应打印一个句子，# 概要地说明T恤的尺码和字样。使用位置实参调用这个函数来制作一件T恤；再使用关键字实参来调用这个函数。# 8-4 大号T恤 ：修改函数make_shirt() ，使其在默认情况下制作一件印有字样“I love Python”的大号T恤。# 调用这个函数来制作如下T恤：一件印有默认字样的大号T恤一件印有默认字样的中号T恤和一件印有其他字样的T恤（尺码无关紧要）。def make_shirt( size, slogen = "I love Python!"): print("Size: " + size) print("Print with: "+slogen)make_shirt("XXL")make_shirt("L", "Hello world") result:1234Size: XXLPrint with: I love Python!Size: LPrint with: Hello world 8-6123456789# 8-6 城市名 ：编写一个名为city_country() 的函数，它接受城市的名称及其所属的国家。这个函数应返回一个格式类似于下面这样的字符串：# "Santiago, Chile"# 至少使用三个城市-国家对调用这个函数，并打印它返回的值。def city_country(country, city): return city+", "+countryprint(city_country("China", "Guangzhou"))print(city_country("Japan", "Tokyo"))print(city_country("America", "Los Angeles")) result:123Guangzhou, ChinaTokyo, JapanLos Angeles, America 8-141234567891011121314# 8-14 汽车 ：编写一个函数，将一辆汽车的信息存储在一个字典中。这个函数总是接受制造商和型号，还接受任意数量的关键字实参。这样调用这个函数：提供必不可# 少的信息，以及两个名称—值对，如颜色和选装配件。这个函数必须能够像下面这样进行调用：# car = make_car('subaru', 'outback', color='blue', tow_package=True)def make_car( brand, type, **car_info): car = &#123;&#125; car["brand"] = brand car["type"] = type for key, value in car_info.items(): car[key] = value return carprint(make_car("BMW", "gas", color="black", price="100 milions"))print(make_car("Benz", "gas",))print(make_car("Tesla", "eletric", appearance="cool")) result:123&#123;'brand': 'BMW', 'type': 'gas', 'color': 'black', 'price': '100 milions'&#125;&#123;'brand': 'Benz', 'type': 'gas'&#125;&#123;'brand': 'Tesla', 'type': 'eletric', 'appearance': 'cool'&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bochs虚拟机安装及使用]]></title>
    <url>%2F2018%2F03%2F19%2FBochs%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在学习操作系统时需要用虚拟机进行实验，Bochs虚拟机即是免费的又能够在里面进行调试，因此现在改用Bohcs虚拟机。以下记录了安装和配置的过程(仅在windows下)。 下载安装Bochs可以在此处进行下载： 下载完成后运行安装，建议安装到不需要管理员权限的位置。 配置虚拟机参考自，在bochs根目录下新建一个文件bochsrc，内容为：1234567891011121314megs:32romimage:file=$BXSHARE/BIOS-bochs-latestvgaromimage:file=$BXSHARE/VGABIOS-lgpl-latestfloppya:1_44=a.img,status=insertedboot:floppylog:bochsout.txtmouse:enabled=0keyboard: keymap=$BXSHARE/keymaps/x11-pc-de.map 其中，floppya为A盘的软盘映像，若需要使用B盘，可以加上一行floppyb的配置。 创建虚拟软盘运行bximage，进行软盘创建： 可以看到这个默认的a.img就是上一步中的a盘，我们将二进制文件复制进去运行。 运行虚拟机在Bochs的根目录下，按shift+右键打开power shell窗口，输入1.\bochs.exe -qf bochsrc 运行刚刚配置好的虚拟机（注意，此时a.img中的首扇区必须有正确格式的引导程序，否则会报错） 使用dd进行文件合并在修改软盘时，每次都要用WinHex进行手动修改实在是太麻烦了，Linux上有dd进行文件合并、分割，万幸，在Windows下也有dd for Windows可以帮助我们进行文件合并与分割，下载链接在这里(已修改) 使用时，可以用以下语句：1dd if=3_2_0.bin of=a.img bs=512 count=1 if：输入文件 of：输出文件 bs：每一块的默认大小（512字节） seek：在输出时，跳过of的块数量 skip：在复制时，跳过if的块数量 count：复制的块的数量 conv：输出时文件格式，其中conv=notrunc为不截断输出文件 还有其它参数及conv的其它值可进行选择，这里只举出常用的不一一列举。]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业03-条件语句&字典]]></title>
    <url>%2F2018%2F03%2F19%2Fpython%E4%BD%9C%E4%B8%9A03-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%26%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[Description (if)Select from exercise 5-1 to 5-13 Code (if)5-31234567891011# 5-3 外星人颜色#1 ：假设在游戏中刚射杀了一个外星人，请创建一个名为alien_color 的变量，# 并将其设置为'green' 、'yellow' 或'red' 。# 编写一条if 语句，检查外星人是否是绿色的；如果是，就打印一条消息，指出玩家获得了5个点。# 编写这个程序的两个版本，在一个版本中上述测试通过了，而在另一个版本中未通过（未通过测试时没有输出）。alien_color = "green"if alien_color == "green": print("Get 5 points!")alien_color = "yellow"if alien_color == "green": print("Get 5 points!") result:1Get 5 points! 5-61234567891011121314151617181920# 5-6 人生的不同阶段 ：设置变量age 的值，再编写一个if-elif-else 结构，根据age 的值判断处于人生的哪个阶段。def howold(age): if age&lt;2: print("a baby")# 如果一个人的年龄小于2岁，就打印一条消息，指出他是婴儿。 elif age&lt;4: print("learning how to walk")# 如果一个人的年龄为2（含）～4岁，就打印一条消息，指出他正蹒跚学步。 elif age&lt;13: print("a child")# 如果一个人的年龄为4（含）～13岁，就打印一条消息，指出他是儿童。 elif age&lt;20: print("a teenage")# 如果一个人的年龄为13（含）～20岁，就打印一条消息，指出他是青少年。 elif age&lt;65: print("an adult")# 如果一个人的年龄为20（含）～65岁，就打印一条消息，指出他是成年人。 else: print("the old")# 如果一个人的年龄超过65（含）岁，就打印一条消息，指出他是老年人。howold(1)howold(3)howold(5)howold(18)howold(24)howold(90) result:123456a babylearning how to walka childa teenagean adultthe old 5-81234567891011# 5-8 以特殊方式跟管理员打招呼 ：创建一个至少包含5个用户名的列表，且其中一个用户名为'admin' 。# 想象你要编写代码，在每位用户登录网站后都打印一条问# 候消息。遍历用户名列表，并向每位用户打印一条问候消息。# 如果用户名为'admin' ，就打印一条特殊的问候消息，如“Hello admin, would you like to see a status report?”。# 否则，打印一条普通的问候消息，如“Hello Eric, thank you for logging in again”。users = ["Eric", "Kris", "Smith", "admin", "Harry"]for user in users: if user == "admin": print("Hello admin, would you like to see a status report?") else: print("Hello "+user+", thank you for logging in again!") result:12345Hello Eric, thank you for logging in again!Hello Kris, thank you for logging in again!Hello Smith, thank you for logging in again!Hello admin, would you like to see a status report?Hello Harry, thank you for logging in again! 5-9123456789101112# 5-9 处理没有用户的情形 ：在为完成练习5-8编写的程序中，添加一条if 语句，检查用户名列表是否为空。# 如果为空，就打印消息“We need to find some users!”。# 删除列表中的所有用户名，确定将打印正确的消息users = []if users: for user in users: if user == "admin": print("Hello admin, would you like to see a status report?") else: print("Hello " + user + ", thank you for logging in again!")else: print("We need to find some users!") result:1We need to find some users! 5-11123456789101112131415# 5-11 序数 ：序数表示位置，如1st和2nd。大多数序数都以th结尾，只有1、2和3例外。# 在一个列表中存储数字1~9。# 遍历这个列表。# 在循环中使用一个if-elif-else 结构，以打印每个数字对应的序数。输出内容应为1st 、2nd 、3rd 、4th 、5th 、# 6th 、7th 、8th 和9th ，但每个序数都独占一行。numbers = range(1, 10)for number in numbers: if number == 1: print('1st') elif number == 2: print('2nd') elif number == 3: print('3rd') else: print(str(number)+'th') result:1234567891st2nd3rd4th5th6th7th8th9th Description (dictionary)Select from exercise 6-1 to 5-13 Code (dictionary)6-31234567891011121314# 6-3 词汇表 ：Python字典可用于模拟现实生活中的字典，但为避免混淆，我们将后者称为词汇表。# 想出你在前面学过的5个编程词汇，将它们用作词汇表中的键，并将它们的含义作为值存储在词汇表中。# 以整洁的方式打印每个词汇及其含义。为此，你可以先打印词汇，在它后面加上一个冒号，再打印词汇的含义；也可在一行打印词汇，# 再使用换行符（\n ）插入一个空行，然后在下一行以缩进的方式打印词汇的含义。words = &#123; 'if': 'if what happen then do something', 'while': 'loop', 'or': 'in bool, A happens or B happens are both fine', 'var': 'record some number, string, dictionary etc', 'python': 'easy to get star'&#125;print('python: '+words['python']+'.')print('if: '+words['if']+'.') result:12python: easy to get star.if: if what happen then do something. 6-41234567891011# 6-4 词汇表2 ：既然你知道了如何遍历字典，现在请整理你为完成练习6-3而编写的代码，将其中的一系列print# 语句替换为一个遍历字典中的键和值的循环。确定该循环正确无误后，再在词汇表中添加5个Python术语。# 当你再次运行这个程序时，这些新术语及其含义将自动包含在输出中。words['import'] = 'as include in c'words['for'] = 'another loop'words['and'] = 'only if A and B both true'words['class'] = 'var define by coder'words['print'] = 'to print string and begin a new line'for key in words.keys(): print(key + ': '+words[key]+'.') result:12345678910if: if what happen then do something.while: loop.or: in bool, A happens or B happens are both fine.var: record some number, string, dictionary etc.python: easy to get star.import: as include in c.for: another loop.and: only if A and B both true.class: var define by coder.print: to print string and begin a new line. 6-8123456789101112131415161718#6-8 宠物 ：创建多个字典，对于每个字典，都使用一个宠物的名称来给它命名；在每个字典中，# 包含宠物的类型及其主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，并将宠物的所有信息都打印出来。pets = [&#123;"name": "Kingkong", "type": "dog", "master": "Tony"&#125;, &#123;"name": "Kitty", "type": "cat", "master": "Jessica"&#125;, &#123;"name": "Big Bird", "type": "snake", "master": "Jason"&#125;, &#123;"name": "Son", "type": "kangaroo", "master": "Micheal"&#125;, ]for pet in pets: print(pet["name"]+" is a "+pet["type"]+", it is "+pet["master"]+"'s friend!") result:1234Kingkong is a dog, it is Tony's friend!Kitty is a cat, it is Jessica's friend!Big Bird is a snake, it is Jason's friend!Son is a kangaroo, it is Micheal's friend!]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业02-列表]]></title>
    <url>%2F2018%2F03%2F13%2FPython%E4%BD%9C%E4%B8%9A02-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 3-1 to 4-15 Code3-1 &amp; 3-212345678# 3-1 姓名: 将一些朋友的姓名存储在一个列表中，并将其命名为names。# 依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。# 3-2 问候语：继续使用练习3-1中的列表，但不打印每个朋友的姓名，# 而为每人打印一条消息。每条消息都包含相同的问候语，但抬头为相应朋友的姓名。names = ["tony", "marry","tom","ma"]for name in names: print(name.title()+": ") print("Hello, "+name+" .") result: 12345678910Tony: Hello, tony .Marry: Hello, marry .Tom: Hello, tom .Ma: Hello, ma .Process finished with exit code 0 3-4 ~ 3-73-4123456# 3-4 嘉宾名单 ：如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），# 你会邀请哪些人？请创建一个列表，其中包含至少3个你想邀请的人；# 然后，使用这个列表打印消息，邀请这些人来与你共进晚餐。names = ["Tom","Raker", "Gakki"]for name in names: print("Hi, "+name+" .Would you like to have dinner with me?") result: 123Hi, Tom .Would you like to have dinner with me?Hi, Raker .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-512345678# 3-5 以完成练习3-4时编写的程序为基础，在程序末尾添加一条print 语句，指出哪位嘉宾无法赴约。# 修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。# 再次打印一系列消息，向名单中的每位嘉宾发出邀请。new_name = "Tony"print(names[1]+" cannot come, "+new_name+" will instead.")names[1] = new_namefor name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234Raker cannot come, Tony will instead.Hi, Tom .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-6123456789101112# 3-6 添加嘉宾 ：你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。# 以完成练习3-4或练习3-5时编写的程序为基础，在程序末尾添加一条print 语句，指出你找到了一个更大的餐桌。# 使用insert() 将一位新嘉宾添加到名单开头。# 使用insert() 将另一位新嘉宾添加到名单中间。# 使用append() 将最后一位新嘉宾添加到名单末尾。# 打印一系列消息，向名单中的每位嘉宾发出邀请。print("Good news! I find a larger table!")names.insert(0,"Dollus")names.insert(2,"Sam")names.append("Lilith")for name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234567Good news! I find a larger table!Hi, Dollus .Would you like to have dinner with me?Hi, Tom .Would you like to have dinner with me?Hi, Sam .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me?Hi, Lilith .Would you like to have dinner with me? 3-71234567891011121314# 3-7 缩减名单 ：你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。# 以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。# 使用pop() 不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。# 对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。# 使用del 将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的。print("I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.")while len(names)&gt;2: sorry_name = names.pop() print("Hi "+sorry_name+", I'm sorry to tell you that I cannot have dinner with you.")for name in names: print("Hey "+name+", you are still in my invite list!")del names[0]del names[0]print(names) result: 12345678I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.Hi Lilith, I'm sorry to tell you that I cannot have dinner with you.Hi Gakki, I'm sorry to tell you that I cannot have dinner with you.Hi Tony, I'm sorry to tell you that I cannot have dinner with you.Hi Sam, I'm sorry to tell you that I cannot have dinner with you.Hey Dollus, you are still in my invite list!Hey Tom, you are still in my invite list![] 3-8 ~ 3-113-81234567891011121314151617181920212223242526272829303132333435# 3-8 放眼世界 ：想出至少5个你渴望去旅游的地方。places = ["Egypt", "Tibet", "France", "Russia", "Australia"]# 将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。print("按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:")print(places)print("使用sorted() 按字母顺序打印这个列表，同时不要修改它:")print(sorted(places))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:")print(sorted(places, reverse=True))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:")places.reverse()print(places)print("使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:")places.reverse()print(places)print("使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:")places.sort()print(places)print("使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:")places.sort(reverse=True)print(places) result: 1234567891011121314151617181920按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按字母顺序打印这个列表，同时不要修改它:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:['Australia', 'Russia', 'France', 'Tibet', 'Egypt']使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']Process finished with exit code 0 3-912# 使用len()打印一条消息，指出想要游玩多少个国家。print("I want to go "+str(len(places))+" places.") result: 1I want to go 5 places. 3-111234# 3-11 有意引发错误 ：如果你还没有在程序中遇到过索引错误，就尝试引发一个这种错误。# 在你的一个程序中，修改其中的索引，以引发索引错误。关闭程序前，# 务必消除这个错误。print(places[7]) result: 123File "D:/pyproject/homework1/3-8.py", line 43, in &lt;module&gt; print(places[7])IndexError: list index out of range 4-212345678910# 4-2 动物 ：想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for 循环将每种动物的名称都打印出来。animals = ["dog", "cat", "hamster"]for animal in animals: print(animal)# 修改这个程序，使其针对每种动物都打印一个句子，如“A dog would make a great pet”。for animal in animals: print("A "+animal+" would make a good pet.")# 在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如“Any of these animals would make a great pet!”这样的句子。print("Any of these animals would make a greate pet!") result:123456789dogcathamsterA dog would make a good pet.A cat would make a good pet.A hamster would make a good pet.Any of these animals would make a greate pet!Process finished with exit code 0 4-3 ~ 4-94-3123# 4-3 数到20 ：使用一个for 循环打印数字1~20（含）。for number in range(1, 21): print(number) result:12345678910111213141516171819201234567891011121314151617181920 4-5123456# 4-5 计算1~1 000 000的总和 ：创建一个列表，其中包含数字1~1 000 000，再使用min() 和max() 核实该列表确实是从1开始，# 到1 000 000结束的。另外，对这个列表调用函数sum() ，看看Python将一百万个数字相加需要多长时间。numbers = range(1, 1000001)print(min(numbers))print(max(numbers))print(sum(numbers)) result:12311000000500000500000 4-61234# 4-6 奇数 ：通过给函数range() 指定第三个参数来创建一个列表，其中包含1~20的奇数；再使用一个for 循环将这些数字都打印出来。odd_numbers = range(1,20,2)for odd_number in odd_numbers: print(odd_number) result:12345678910135791113151719 4-9123# 4-9 立方解析 ：使用列表解析生成一个列表，其中包含前10个整数的立方。cube_numbers = [ number**3 for number in range(1,11)]print(cube_numbers) result:1[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] 4-10 &amp; 4-114-1012345678910# 4-10 切片 ：选择你在本章编写的一个程序，在末尾添加几行代码，以完成如下任务。# 打印消息“The first three items in the list are:”，再使用切片来打印列表的前三个元素。# 打印消息“Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。# 打印消息“The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。print("The first three items in the list are:")print(cube_numbers[:3])print("Three items from the middle of the list are:")print(cube_numbers[3:6])print("The last three items in the list are:")print(cube_numbers[6:]) result:123456The first three items in the list are:[1, 8, 27]Three items from the middle of the list are:[64, 125, 216]The last three items in the list are:[343, 512, 729, 1000] 4-11copy a list123456789101112131415161718print("list A:")A = ["A", "E", "I", "O"]print(A)print("list B copy from A:")B = A[:]print(B)print("Change B and A didn't change:")B.append("U")print(A)print(B)print("C equal to A directly:")C = Aprint(A)print(C)print("C change and make A change:")C.pop()print(A)print(C) result:12345678910111213list A:['A', 'E', 'I', 'O']list B copy from A:['A', 'E', 'I', 'O']Change B and A didn't change:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O', 'U']C equal to A directly:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O']C change and make A change:['A', 'E', 'I']['A', 'E', 'I'] 4-1312345# 4-13 自助餐 ：有一家自助式餐馆，只提供五种简单的食品。请想出五种简单的食品，并将其存储在一个元组中。# 使用一个for 循环将该餐馆提供的五种食品都打印出来。foods = ("apple", "juice", "pizza", "noodles", "egg")for food in foods: print(food) result:12345applejuicepizzanoodlesegg 12# 尝试修改其中的一个元素，核实Python确实会拒绝你这样做。foods[3] = "chicken" result:123456Traceback (most recent call last): File "D:/pyproject/homework1/4-2.py", line 18, in &lt;module&gt; foods[3] = "chicken"TypeError: 'tuple' object does not support item assignmentProcess finished with exit code 1 12345# 餐馆调整了菜单，替换了它提供的其中两种食品。请编写一个这样的代码块：# 给元组变量赋值，并使用一个for 循环将新元组的每个元素都打印出来。foods = ("apple", "cola", "cabbage", "noodles", "egg")for food in foods: print(food) result:12345applecolacabbagenoodlesegg PEP格式指南 四空格缩进 行最长不超过80字符 不要在程序中过多地使用空行 适当的注释 …]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello blog again]]></title>
    <url>%2F2018%2F03%2F11%2Fhello-blog-again%2F</url>
    <content type="text"><![CDATA[之前的博客是直接克隆自他人的博客代码再进行修改，不太好意思。而且不自己从开始建的话，很多配置用不了、不知道如何更改，因此趁周末闲暇从新用hexo建站并上传至GitHub Pages，并配置好了主题等，特地记录一下踩过的、好的文章和添加的功能。 搭建过程及相关教程下载hexo在桌面右键选择Git Bash here，并输入 npm install -g hexo-cli 等待安装，找个网络比较好的地方等吧…… 接下来具体的部署内容详见这个教程，算是见得比较全的一篇教程了。 添加主题NexT将主题下载然后放进/theme，我这里用的是NexT主题。具体参见NexT项目，以及使用文档 添加的功能 RSS订阅 添加分类页 背景动画 站内搜索 访问量统计 使用Gitment添加评论 支持markdown代码高亮 踩过的坑markdown编辑器的选择一开始用的NotePad++，首先是不支持预览，其次是它的front-matter添加后会被当成普通的markdown语法。因此现在改用vscode进行markdown的编辑器。 具体的使用方法：打开.md文件进行编辑，按Ctrl+k再按v即可打开预览窗口，效果如下： 使用Gitment添加评论 NexT预置Gitment： 一开始使用Gitment添加时找到的是过去版本的教程，需要修改代码，但是在修改的过程中突然发现原本的文件已经包含了Gitment模块，这才知道NexT的新版本已经预置了Gitment，配置方法参考自这里。 关于Error: Not Found: 配置时要注意仓库名称要是该仓库本名，而非SSH或HTTPS，例如我的就是Skyraker.github.io。 关于Error：validation failed: Gitment的原理就是在关联你的项目，每一个页面下的评论对应一个issue，并给那个issue建立标签gitment和id，其中id是Gitment唯一确定评论显示于哪个位置的特征。而出现Error：validation failed是因为id超出了issue的50个字符的限制。这个id是怎么来的呢？ 在相应的主题中搜索Gitment即可定位至gitment.swig，打开找到id可以看到： id: window.location.pathname, 即当前id为这个页面在本站中的路径。当文章title为中文时，转码会导致id过长。我们可以改路径名（即permlink）,具体详见这里，或者改id为 id: &apos;{{ page.date }}&apos; 或 id: &apos;{{ page.title }}&apos; 以缩短id，但注意这两个数据必须是唯一的，不能重复，否则评论会在多个页面共享。参考并修改自这里 初始化本页页面后，可能没那么快加载出来，不要重复初始化，否则会出现两个相同的issue 代码高亮在站点配置文件中，修改配置： highlight: enable: true auto_detect: true line_number: true tab_replace: 即可打开代码高亮的自动探测、行号显示。 在主题配置文件中，修改配置选择高亮风格： 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 最后在编辑markdown时，引用代码，可以得到如下效果：123456#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello world!"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OS学习笔记01-接管裸机控制权]]></title>
    <url>%2F2018%2F03%2F10%2FOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)%E6%8E%A5%E7%AE%A1%E8%A3%B8%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%9D%83%2F</url>
    <content type="text"><![CDATA[实验任务设计一个引导扇区程序，程序功能是：在屏幕上显示运动内容，并在触碰到边框时反弹，可以加入变色等其它功能。将这个程序的机器码放进放进虚拟软盘的首扇区，并用此软盘引导无操作系统的虚拟机，直到成功。 基础原理主引导记录（MBR）工作原理：计算机启动后，由BIOS检查硬件并根据指定的顺序，检查引导设备（本次实验中的虚拟软盘）的第一扇区（即前512B且以0x55AA结尾的内容，也就是我们的主引导记录），加载至内存地址0x7C00，并开始运行；其它内存地址如下所示： 显示原理：显存首地址为0xB800，以两个字节来控制相应屏幕位置的显示内容。其中低字节为显示字符的ascii码，高字节为显示颜色，显示颜色如下表： 其中，颜色默认为0x07，即黑底白字； 实验工具和环境说明 编辑器：Notepad++，支持语法高亮； 汇编器：NASM，与MASM有部分区别，后文详述； 机器码编辑器：WinHex，用于对COM进行修改使其符合MBR的格式 虚拟机：VMware，用于生成裸机 程序流程及源码显示个人信息跳动规迹，并变色； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222;显示学号姓名缩写 DRt equ 1 ;D-Down,U-Up,R-right,L-Left URt equ 2 ; ULt equ 3 ; DLt equ 4 ; delay equ 50000 ;计时器延迟计数,用于控制画框的速度 ddelay equ 580 ;延迟580*50000次 Hm equ 25 ;最大高度 Lm equ 80 ;最大宽度 len equ 14 ;字符串长度 BOOTSEG equ 0x7c00 ;段基址0x7c00 DISPLAYSEG equ 0xb800 ;显存及地址0xb800 org BOOTSEG ;告诉汇编器要在0x7c00执行 section .text_start: ;初始化数据段，使其指向0X7C00处，即Boot代码被加载的地方 mov ax, cs mov ds, ax ;将文本显示内存段基址 放在ES中，供后面显示字符使用 mov ax, DISPLAYSEG mov es, ax loop1: dec word[count] ; 递减计数变量 jnz loop1 ; &gt;0：跳转; mov word[count],delay dec word[dcount] ; 递减计数变量 jnz loop1 mov word[count],delay mov word[dcount],ddelay ;mov al, 20H ;空格覆盖 ;mov ah, 0FH ;mov [es:bx], ax dec byte[color] cmp byte[color], 01H jz resetback: mov al, DRt ;↘ cmp al, byte[dir] jz DRF mov al, DLt ;↙ cmp al, byte[dir] jz DLF mov al, URt ;↗ cmp al, byte[dir] jz URF mov al, ULt ;↖ cmp al, byte[dir] jz ULF jmp $DRF: inc word[x] inc word[y] ;向右下前进一格 mov ax, Hm mov bx, word[x] ;判断x是否越界 cmp ax, bx jz dr2ur mov ax, Lm-len mov bx, word[y] ;判断y是否越界 cmp ax, bx jz dr2dl jmp displaydr2ur: ;回弹——从右下改为右上 mov word[x], Hm-2 mov ax, Lm-len ;判断是否为角落 mov bx, word[y] cmp ax, bx jz drA mov byte[dir], URt jmp displaydr2dl: mov word[y], Lm-len-2 mov byte[dir], DLt jmp displaydrA: ;角落时原路返回 mov word[y],Lm-len-2 mov byte[dir], ULt jmp display DLF: inc word[x] dec word[y] mov ax, Hm mov bx, word[x] cmp ax, bx jz dl2ul mov ax, -1 mov bx, word[y] cmp ax, bx jz dl2dr jmp displaydl2ul: mov word[x], Hm-2 mov ax, -1 mov bx, word[y] cmp ax, bx jz dlA mov byte[dir], ULt jmp displaydl2dr: mov word[y], 1 mov byte[dir], DRt jmp displaydlA: mov word[y], 1 mov byte[dir], URt jmp display URF: dec word[x] inc word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ur2dr mov ax, Lm-len mov bx, word[y] cmp ax, bx jz ur2ul jmp displayur2dr: mov word[x], 1 mov ax, Lm-len mov bx, word[y] cmp ax, bx jz urA mov byte[dir], DRt jmp displayur2ul: mov word[y], Lm-len-2 mov byte[dir], ULt jmp displayurA: mov word[y], Lm-len-2 mov byte[dir], DLt jmp display ULF: dec word[x] dec word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ul2dl mov ax, -1 mov bx, word[y] cmp ax, bx jz ul2ur jmp displayul2dl: mov word[x], 1 mov ax, -1 mov bx, word[y] cmp ax, bx jz ulA mov byte[dir], DLt jmp displayul2ur: mov word[y], 1 mov byte[dir], URt jmp displayulA: mov word[y], 1 mov byte[dir], DRt jmp display display: ;显示模块 mov ax, word[x] mov bx, Lm mul bx add ax, word[y] mov bx, 2 mul bx mov bx, ax ;bx = ax = (x*80+y) * 2 mov cx, len mov si, info mov ah, [color]loop_str: ;字符串显示模块 mov al, [si] mov [es:bx], ax inc si inc bx inc bx loop loop_str jmp loop1reset: mov byte[color], 0FH jmp backend: jmp $;section .data info db " ygz 16337287 ",0 count dw delay dcount dw ddelay dir db DRt ; 向右下运动 x dw 2 y dw 0 color db 0FH times 510-($-$$) db 0 ;填充空格 dw 0xaa55 实验步骤 在NotePad++中进行编辑程序; 在生成软盘文件： 打开CMD终端窗口至asm文件所在的文件夹，输入nasm -f bin %name%.asm -o %name%.com &gt; amsg.txt（%name%为文件名）； 或直接输入na %name%.asm快速生成com文件，na.bat内容如下：@echo offset name=%~n1nasm -f bin %name%.asm -o %name%.COM &gt; amsg.txttype amsg.txt |find “Error”type amsg.txt |find “Warn” 生成com文件，打开com文件将0x1FE和0x1FF改为0x55和0xAA，保存为flp软盘格式: 另：若代码末尾已经加上了times 510-($-$$) db 0 ;填充空格dw 0xaa55 ;加上55AA，符合MBR特征则不必再修改com文件，直接生成为flp文件即可 创建无操作系统的裸机： 将flp文件装载进虚拟机作为MBR引导启动： 结果截图 显示有规迹的‘A’： 显示动态无规迹的‘A’+固定的个人信息‘ ygz 16337287 ’： 逐字显示动态变色个人信息，并保留痕迹： 整行显示动态变色个人信息： 接下来就是各种踩坑和填坑的经历了 关于NASM： NASM的标识符区分大小写； NASM中，memory操作数直接是内容地址，并且不保存数据类型，导致以下两个区别： 在读取数据内容时，要加方括号[ ] 指明是地址的内容，若没有方括号则是首地址的值； 在操作数据内容时且另一个操作数是常数（非ax、ah这种能够知道数据大小的寄存器），要加上数据类型如byte、word等； 不需要ptr指示字； 提供segment时，NASM要在方括号内提供segment，如：MOV [es:bx], ax 段定义方式，NASM定义数据段section .data，定义代码段section .text equ类似C语言中的define，用于定义整数常量；（注意，不能定义浮点数，且最长为8bytes） 用times来重复定义数据或指令 $为当前nasm编译后当前指令位置，$$为该段的初始位置。一开始在没弄懂$$的情况下照猫画虎胡乱使用，导致生成的文件大于512B且0x55AA位置错误（虽然没有影响），后来去掉了section .data后即可（即让后面的数据处于与代码的同一段，以便于计算总体机器码的大小）。 其它的NASM需要注意的语法待后面的实验探索。关于加载至0x7c00：BIOS检查了引导设备的第一个扇区（以0x55AA结尾的512B）即主引导记录（MBR），加载至0x7c00，因此默认偏移为0x7c00。至于为什么时0x7c00，是由于一开始的8088CPU内存为32KB，即0~0x7FFF，保留512B给MBR，512B保留给MBR产生的数据，为了让出足够的空间给操作系统，因此从后开始算，0x7FFF-1024 = 0x7c00;关于org的作用及思考：根据上一条，我们的代码将会被强制加载到0x7c00，因此若没有org，后面的memory操作数会默认从0开始算。 例如在相对位置3做了如下定义： msg db ‘@’ 在没有org的情况下，[msg]会在0x03读取一位，而真正的数据‘@’被加载到了0x7c03，在读取[msg]的时候就会读到乱码。 在有org 0x7c00的情况下，[msg]会直接去0x7c03读取’@’。 以上可以在生成机器码后，通过反汇编看出。总的来说，org就是告诉汇编器，该代码必然会被加载到某一偏移值上，因此要告诉汇编器后面的相对地址要加上偏移值。 这也就能够解释一个现象：明明在数据段中初始化了数据，却无法读取，只能在代码开头重新mov一遍才能正常输出，但是重复mov时的目的地址为0x7c00前面的某个位置，造成别的内存的篡改，产生不可预计的后果。 关于算法的错误： 角落判断：在一开始的设计中，仅分别判断了x和y的位置，若字符运行至角落，仅仅将x反弹，而y会继续运动，而且运动方向也会错误，导致一次显示错误的同时也造成了y的越界，且会越跑越远，最终让字符完全移出屏幕，如下图可见在后期字符的反弹条件已经错误了 修改方法：在判断x越界后的反弹程序中，判断y是否同时越界，若是，则将路径原路返回 在部分不需要写回的相等判断中，用了sub，其实用cmp即可； 不足及优化设想：在整体信息输出弹跳时，本想着每次弹跳后才变色的，视觉效果会好很多，但是在弹跳时加了判断后（即十二种弹跳），会超出512B限制,导致部分指令无法装载。有两种优化设想： 将DRt等数据不局限于一个特征数，而是按规律如上下分别为1、0来进行编写，在弹跳时通过运算来更改路径，合并重复逻辑； 在MBR中进行引导而非操作，真正的操作放在操作系统的位置执行。 这两种方法都有待进一步的实践。 入门摸索，难免有纰漏，欢迎各位大佬批评指正 参考资料 “Hello world” 引导程序 NASM与MASM语法区别 主引导记录内存地址是0x7c00 关于org 0x7c00的原因]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业01-变量和简单数据类型]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08-Python%E4%BD%9C%E4%B8%9A01-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 2-1 to 2-11. I will finish the code with comment about the requirement. Code2-3123456# 2-3 个性化消息： 将用户的姓名存到一个变量中，# 并向该用户显示一条消息。显示的消息应非常简单，# 如“Hello Eric, would you like to learn some Python today?”。name = input()print("Hello " + name + ", would you like to learn some Python today?") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_3.py Jobs Hello Jobs, would you like to learn some Python today? Process finished with exit code 0 2-41234567# 2-4 调整名字的大小写： 将一个人名存储到一个变量中，# 再以小写、大写和首字母大写的方式显示这个人名。name = input()print(name.upper())print(name.lower())print(name.title()) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_4.py sKy raKeR SKY RAKER sky raker Sky Raker Process finished with exit code 0 2-71234567891011121314151617# 2-7 剔除人名中的空白： 存储一个人名，# 并在其开头和末尾都包含一些空白字符。# 务必至少使用字符组合"\t" 和"\n" 各一次。# 打印这个人名，以显示其开头和末尾的空白。# 然后，分别使用剔除函数lstrip() 、rstrip()# 和strip() 对人名进行处理，并将结果打印出来。name = "\n\tSky Raker\t\n\t"print("-------------")print(name)print("-------------")print(name.lstrip())print("-------------")print(name.rstrip())print("-------------")print(name.strip())print("-------------") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_7.py ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Process finished with exit code 0 2-812345678# 2-8 数字8： 编写4个表达式，它们分别使用# 加法、减法、乘法和除法运算，但结果都是数字8。# 为使用print 语句来显示结果，务必将这些表达式用括号括起来，print(3+5)print(10-2)print(2*4)print(1000/125) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_8.py 8 8 8 8.0 Process finished with exit code 0 2-111234# 2-11 Python之禅： 在Python终端会话中执行命令import this ，# 并粗略地浏览一下其他的指导原则。import this result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_11.py The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! Process finished with exit code 0]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Python]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Python%2F</url>
    <content type="text"><![CDATA[Python 的优点作为一个流行的解释型语言，python具有以下优点： 拥有许多强大的库，以支持python在各个领域的使用，也是许多人开始学习python的原因,例如： Web框架方面的Django等 科学计算方面的NumPy和SciPy等 用于解析HTML等的BeautifulSoup 用于图像处理的PIL以及支持python3的Pillow 用于多媒体、游戏开发的PyGame 机器学习的scikit-learn … 对初学者友好的学习曲线 … Python 的使用若仅仅进行少量的代码编写，可以使用文本编辑器写python代码再放到解释器下运行。若要进行更多的开发，可以用IDE，例如PyCharm、Eclipse&#39;s PyDev或轻量级的Geany。我目前使用的是PyCharm。 Python 官网探索在学习python之初，我们来看一下它官网的内容：Python 1. 社区：可以进行讨论交流、参与会议、参与活动等等； 2. 初学引导：初学者入门的手册、指南、帮助等； 3. 下载：python的相关下载、环境配置； 4. 帮助文档：在学习时要多参考帮助文档，里面有针对初学、进阶等各个阶段的帮助； 5. 最新关于python的新闻； 6. 即将到来的活动； 7. python的应用领域以及相关库； 网页上还有其它的类似成功故事、新闻、加入团队等链接就不一一赘述了。 目标 掌握python编程思想和基本语法，对常用库有一定的了解； 能够在日常生活中应用python脚本解决一些重复性的、机械的问题； 用python写爬虫，并学会用python进行数据处理； 希望能够利用python去学习一些机器学习的内容。 在python中输入import this，会出现一首诗Zen of Python: The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! 与各位共勉！]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Blog%2F</url>
    <content type="text"><![CDATA[Hello Blog在很久之前就有搭一个自己的博客的想法，但是一直缺乏行动，同样的，一直想开始使用GitHub也没有静下心来研究一下。正巧《高级编程技术》的老师要求把作业项目提交到博客上，借着这次机会尝试使用GitHub Pages进行个人博客的搭建，尝试过hexo和jekyll都没有成功，只能cloneYanB大佬的博客，再参照所使用的NexT模板进行修改。另外，大佬还推荐了一个在线编辑GitHub Pages上博客的在线编辑平台prose，可以在线修改编辑博客并上传。很感谢大佬的教学！ 博客内容这个博客将会分享一些在学习过程中的心得、参与的项目以及其它的一些想分享的东西。未来或许会尝试用英文写作。希望能养成写博客的习惯，及时总结。 需要改进的地方 markdown的代码高亮配置。 虽然借助别人已经生成的模板也搭建出来了现在的这个博客，但依旧希望能够学会用jekyll并用来进行进一步的个性化调整。 挖掘博客的一些有趣的应用。]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
