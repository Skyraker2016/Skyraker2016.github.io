<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Bezier三次曲线]]></title>
    <url>%2F2018%2F05%2F30%2FBezier%E4%B8%89%E6%AC%A1%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/Bezier文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./Bezier 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM 编译参数：1g++ -o Bezier Bezier.cpp -lGL -lGLU -lglut -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lpthread -lGLEW -ldl 功能说明： 鼠标左键点击，选择四个点绘制成相应的bezier三次曲线 回车键保留该曲线，并去除草稿线 退格键删除上一条曲线 效果演示： 绘制一条曲线 删除曲线 兔子 知识点 获取鼠标位置：鼠标移动回调函数： 1234void mouse_move_callback(GLFWwindow* window, double xpos, double ypos)&#123; mouseX = xpos; mouseY = ypos;&#125; Bezier公式： $$ B(t) = P_0(1-t)^3 + 3P_1t(1-t)^2+3P_2t^2(1-t)+P_3t^3, t \in [0,1] $$ 具体实现： 12345678910111213141516void bezier(vector&lt;vector&lt;GLfloat&gt;&gt; &amp;line, int n)&#123; float step = 1.0f / n; float a, b, c, d; for (int i=0; i&lt;=n; i++)&#123; float these = step * i; a = (1-these) * (1-these) * (1-these); b = (1-these) * (1-these) * these * 3; c = (1-these) * these * these * 3; d = these * these * these; vector&lt;GLfloat&gt; tmp; tmp.push_back(a * pos[0][0] + b * pos[1][0] + c * pos[2][0] + d * pos[3][0]); tmp.push_back(a * pos[0][1] + b * pos[1][1] + c * pos[2][1] + d * pos[3][1]); tmp.push_back(a * pos[0][2] + b * pos[1][2] + c * pos[2][2] + d * pos[3][2]); line.push_back(tmp); &#125;&#125; 源代码参考[绘制bezier曲线](https://blog.csdn.net/qa1041335855/article/details/72083760)]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib库学习]]></title>
    <url>%2F2018%2F05%2F29%2FMatplotlib%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Learning matplotlib, a lib to draw chart, figure, etc.. Exercise 11.1: Plotting a functionPlot the function$$ f(x) = sin^2(x-2)e^{-x^2} $$over the interval [0, 2]. Add proper axis labels, a title, etc. Code1234567891011import matplotlib.pyplot as plt import numpy as npplt.figure(1)x = np.linspace(0, 2, 100)y = [ np.sin( x[i] - 2 ) ** 2 * np.exp(- x[i]*x[i]) for i in range(len(x)) ]plt.plot(x,y)plt.title('f(x) = sin^2(x-2)*e^(-x^2)')plt.xlabel('x')plt.ylabel('y')plt.show() Result Knowledge 用pip3 install matplotlib进行安装 遇到问题ModuleNotFoundError: No module named &#39;tkinter&#39;，按教程解决，即用apt install python3-tk安装。 用plot绘制曲线，xlabel、ylabel设置坐标轴名称，title设置图像标题 Exercise 11.2: DataCreate a data matrix X with 20 observations of 10 variables. Generate a vector b with parameters. Then generate the response vector $y = Xb+z$ where z is a vector with standard normally distributed variables. Now (by only using y and X), find an estimator for b, by solving$$ \hat{b} = arg\min\limits_{b} || Xb-y ||_2 $$Plot the true parameters b and estimated parameters b̂. See Figure 1 for an example plot. Code1234567891011121314151617import matplotlib.pyplot as plt import numpy as npX = np.random.rand(20, 10) * 10 # 增长10倍增大差异b = np.random.rand(10, 1)z = np.random.normal(size=(20, 1))y = X.dot(b) + zx = np.linspace(0, 9, 10)b_ = np.array( np.linalg.lstsq(X, y)[0] )plt.scatter( x, b, c='r', marker='o', label='b')plt.scatter( x, b_, c='b', marker='+', label='$\hat&#123;b&#125;$')plt.legend()plt.show() Result Knowledge .dot()点乘 lstsq()最小二乘法 scatter散点图 legend显示图例 Exercise 11.3: Histogram and density estimationGenerate a vector z of 10000 observations from your favorite exotic distribution. Then make a plot thatshows a histogram of z (with 25 bins), along with an estimate for the density, using a Gaussian kerneldensity estimator (see scipy.stats). See Figure 2 for an example plot. Code12345678910import matplotlib.pyplot as plt import numpy as npfrom scipy import statsz = np.random.normal(0,100,size=(10000,))kernel = stats.gaussian_kde(z)x = np.linspace(-400, 300, 10000)plt.hist(z, 25,rwidth=0.8, density=True)plt.plot(x, kernel.evaluate(x), label='kde')plt.show() Result Knowledge hist to draw a histogram scipy.stats.gaussian_kde to create Gaussian kernel density estimator.]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Numpy库学习]]></title>
    <url>%2F2018%2F05%2F22%2FNumpy%E5%BA%93%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Learning Numpy, a lib of python with matrix and other calculation. PrepareGenerate matrices A, with random Gaussian entries, B, a Toeplitz matrix, where A ∈Rn×m and B ∈Rm×m, for n = 200, m = 500. Code123456789101112import numpy from scipy.linalg import toeplitznumpy.random.seed()n = 200m = 500A = numpy.random.normal(size = [n, m])B = toeplitz(numpy.random.normal(size=m))print("------------A-----------\n"+str(A))print("------------B-----------\n"+str(B)) Result123456789101112131415161718192021222324252627[[-0.49837536 -0.3247838 0.50678674 ..., -1.2703934 0.76603943 0.03755445] [-0.03462894 -0.21418493 1.22520135 ..., 0.84866266 0.40158282 -0.65401731] [ 1.1291174 0.49403126 -0.28698245 ..., 0.61324651 0.73156374 -1.58197964] ..., [-0.68737602 -0.89741706 0.12970931 ..., -0.82061635 0.09854131 1.00242481] [-0.31053207 -0.05350655 -1.51289055 ..., -2.26626492 0.79240834 -0.73548947] [ 0.29646267 0.44302565 1.34552379 ..., 0.12526137 -0.74942753 -1.40240914]]------------B-----------[[ 1.44784231 -0.33696399 -0.1432767 ..., 0.26606438 -0.09475546 -1.50552307] [-0.33696399 1.44784231 -0.33696399 ..., -1.16119122 0.26606438 -0.09475546] [-0.1432767 -0.33696399 1.44784231 ..., -1.39562368 -1.16119122 0.26606438] ..., [ 0.26606438 -1.16119122 -1.39562368 ..., 1.44784231 -0.33696399 -0.1432767 ] [-0.09475546 0.26606438 -1.16119122 ..., -0.33696399 1.44784231 -0.33696399] [-1.50552307 -0.09475546 0.26606438 ..., -0.1432767 -0.33696399 1.44784231]] Knowledge random.normal() to create a matrix with Gaussian entries. toepltitz() to create a toepltitz matrix. random.seed() , without argument, set random seed by system time. Exercise 9.1: Matrix operationsCalculate A + A, AA’, A’A and AB. Write a function that computes A(B − λI) for any λ. Code12345678910111213A_add_A = A + AA_mul_AT = numpy.matmul(A, A.transpose())AT_mul_A = numpy.matmul(A.transpose(), A)A_mul_B = numpy.matmul(A, B)print("---------- A+A -----------\n"+str(A_add_A))print("---------- AA' -----------\n"+str(A_mul_AT))print("---------- A'A -----------\n"+str(AT_mul_A))print("---------- AB ------------\n"+str(A_mul_B))def E_9_1(A, B, N): return numpy.matmul(A, B-N*numpy.eye([len(B), len(B)]))print("--------- E_9_1 ----------\n"+str(E_9_1(A, B, 3))) Result12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970---------- A+A -----------[[-0.99675071 -0.6495676 1.01357349 ..., -2.5407868 1.53207886 0.0751089 ] [-0.06925787 -0.42836986 2.4504027 ..., 1.69732532 0.80316565 -1.30803462] [ 2.25823479 0.98806253 -0.5739649 ..., 1.22649302 1.46312748 -3.16395929] ..., [-1.37475203 -1.79483411 0.25941863 ..., -1.64123271 0.19708262 2.00484962] [-0.62106414 -0.1070131 -3.0257811 ..., -4.53252983 1.58481669 -1.47097894] [ 0.59292533 0.8860513 2.69104758 ..., 0.25052273 -1.49885506 -2.80481829]]---------- AA' -----------[[ 524.50900633 -23.41422424 -8.4109328 ..., -17.09509132 -36.58226516 22.36854305] [ -23.41422424 474.25665538 -20.03371708 ..., -15.65752606 14.95693007 -6.58265367] [ -8.4109328 -20.03371708 534.41749229 ..., -10.27103728 19.68694583 30.70304678] ..., [ -17.09509132 -15.65752606 -10.27103728 ..., 440.6393497 -3.86846872 24.44312808] [ -36.58226516 14.95693007 19.68694583 ..., -3.86846872 460.44551208 -24.6430389 ] [ 22.36854305 -6.58265367 30.70304678 ..., 24.44312808 -24.6430389 533.38452907]]---------- A'A -----------[[ 207.71499004 -8.83528023 17.29332948 ..., 1.35094389 9.97232568 18.87072786] [ -8.83528023 151.22418385 18.14374619 ..., 0.76927965 4.16070767 -16.40379885] [ 17.29332948 18.14374619 205.02249127 ..., -8.18432486 -9.26707911 2.07063859] ..., [ 1.35094389 0.76927965 -8.18432486 ..., 208.97270412 -5.71621365 8.51065013] [ 9.97232568 4.16070767 -9.26707911 ..., -5.71621365 174.85487874 -6.98119382] [ 18.87072786 -16.40379885 2.07063859 ..., 8.51065013 -6.98119382 186.52479968]]---------- AB ------------[[-14.87853525 8.70049763 0.66427479 ..., -40.15235048 38.96819378 36.98761191] [ 8.62765483 -38.65652814 1.54867974 ..., 51.0022929 2.29161362 2.36645638] [-28.67531663 -23.03994764 5.9337154 ..., -1.57998333 35.43202865 -1.02604062] ..., [ 21.1088727 -24.70137887 2.29477385 ..., 20.56806809 -33.32895855 -10.71314031] [ 16.33190225 -17.93547546 -9.57141851 ..., -40.75340698 65.49378203 -19.09691261] [-29.11460503 -43.80853239 35.2469557 ..., 15.52438326 20.15859321 -22.71350542]]--------- E_9_1 ----------[[-13.38340918 9.67484904 -0.85608544 ..., -36.34117028 36.67007549 36.87494856] [ 8.73154164 -38.01397334 -2.12692431 ..., 48.45630492 1.08686515 4.32850831] [-32.06266882 -24.52204143 6.79466275 ..., -3.41972285 33.23733743 3.71989831] ..., [ 23.17100075 -22.0091277 1.90564591 ..., 23.02991715 -33.62458247 -13.72041474] [ 17.26349845 -17.77495581 -5.03274686 ..., -33.95461223 63.116557 -16.89044419] [-30.00399303 -45.13760934 31.21038433 ..., 15.14859916 22.40687581 -18.50627799]] Knowledge matmul() to calculate the mul of 2 matrics. eye(k) to calculate a diagonal matrix, k*k transpose() to return matrix’s Inverse matrix Exercise 9.2: Solving a linear systemGenerate a vector b with m entries and solve Bx = b Code1234b = numpy.random.normal(size=m)x = numpy.linalg.solve(B, b)print("--------- E_9_2 ----------\n"+str(x)) Result12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485--------- E_9_2 ----------[ 0.77346147 -0.80520425 -0.35482528 -0.56178735 -0.21607332 0.09578284 0.45176672 -0.349336 -0.07061673 -0.67937045 0.77608967 0.02769846 -0.00266615 -0.78878366 0.32858871 -0.22730774 0.46410093 0.08025457 -0.39018536 0.31449226 -0.15399999 -0.90204851 0.36424562 0.61096627 0.33907227 -0.78779662 -0.48162797 -0.64274742 0.12995262 0.99430534 -0.14856798 -1.15273747 0.09436944 0.40647302 0.65276383 -0.10382041 0.41243053 -0.29856156 0.63452485 -0.22499859 -0.30249207 -0.14497932 0.85522387 0.21110914 -0.23258855 -0.9897657 -0.31338026 -0.26002534 0.924013 -0.47043625 -0.45807153 -0.75775808 1.12480813 0.30321897 -0.29125859 -0.33289894 -0.64971968 0.50094724 0.36235713 -0.00269059 -0.15268968 -0.01259865 0.41392597 -0.83904654 -0.47292343 -0.18366766 0.15149868 1.16077591 -0.53859254 -0.98168055 -0.42284948 1.11918415 0.47384948 -0.21576477 -0.57785042 0.16373249 0.58937659 0.05069881 -0.60646457 -0.07515867 -0.25892701 0.60705024 -0.40504958 -0.41706291 0.02971281 0.69272723 -0.27455502 -0.26949703 -0.88870169 -0.1796936 0.3022728 0.32450019 -0.40309466 -0.28997186 0.28757543 0.83201615 0.18273413 0.19503945 -0.83802164 0.13698447 0.35706851 0.41057604 0.15437131 -0.12593118 -0.78262502 0.46311827 0.18733747 -0.12280002 -0.17000113 0.72736406 0.04638688 -0.0446584 -0.3740762 0.10985653 0.55118338 0.58155485 -0.31415809 0.02940531 0.26057846 1.10319678 0.32003339 -0.66484382 -0.24373552 0.85396941 0.25111252 -0.07437428 -0.42373725 -0.00220312 0.49085239 0.58744762 -0.73623476 0.00606373 0.30887715 0.40351642 0.24192468 -0.60608552 -0.06592915 0.57245086 1.18607234 -0.05819671 -0.63773722 -0.8275492 0.47117888 0.8240523 0.09995859 -1.1189529 -0.68472816 0.08958122 0.94135285 -0.21713449 -0.22415887 -0.73924185 -0.00985684 0.53434199 -0.22782094 -0.00677473 0.18406202 0.25589949 0.02174665 -0.47176496 -1.00158691 0.29509947 0.46664914 -0.65511163 -0.15173256 -0.22610517 0.71416397 0.42033317 -0.8626862 -0.95496022 0.41023983 0.69597171 0.79422447 -0.10630244 -0.90460346 0.04098153 0.52159034 0.65757128 -0.40015286 -0.10895269 -0.21034717 0.56477992 0.35828024 0.08569485 -0.29118951 0.26209546 -0.08259761 -0.49767682 0.00403437 0.15095307 0.35145479 0.5900982 0.02764191 -0.2800535 0.37674186 0.24215259 0.19028278 -0.22832022 -0.58452005 0.23195453 1.01708531 0.21018793 -0.07069491 -0.20749496 -0.30999703 0.98823655 0.88781881 0.01026305 -0.31819752 -0.45149265 0.23417009 0.20983107 0.22389019 -0.00310436 0.33739053 -0.02782074 0.05340627 -0.24885277 0.25400433 0.64797729 -0.03559467 -0.05009246 -0.08380507 0.36138515 0.5550696 0.28391703 -0.39964763 0.33188527 -0.15623489 0.53671244 -0.07852636 -0.33260849 -0.26049435 0.16521133 -0.29556138 -0.14604016 0.1189506 -0.72699557 0.75795078 -0.72868493 0.60271873 -0.62082569 0.20283552 0.06472603 0.31866239 -0.90097767 -0.15603714 -0.53582783 0.88605567 -0.36223599 -0.59827917 -1.29951569 0.1108652 0.66520771 0.01635112 -0.47215453 -1.24440155 -0.08236616 0.77307018 0.08110942 0.20703049 -1.09960752 0.53298015 -0.1027147 0.57313429 -0.26114314 0.36161462 -0.63713623 0.24713223 -0.12035843 0.11065281 0.09846977 -0.43356553 -0.02745542 -0.03750936 0.15417482 0.02681122 0.35293284 -0.22082268 0.52545969 -0.52711138 0.94215319 0.59478862 0.44168817 -0.27060941 -0.43870625 0.34660181 1.0296679 0.96253921 0.09362239 0.12398285 -0.32504824 0.59667371 -0.29713152 -0.15533326 -0.08547569 0.24128572 -0.25817327 0.12638511 -0.32930891 0.34818106 0.62209695 0.00579373 -0.09340648 0.29222168 0.50828812 0.03484351 0.3983519 -0.65951852 0.07763202 0.09992687 0.31966399 0.19685432 -0.37118144 -0.13390334 0.54808429 0.50920353 -0.074975 -0.76687343 -0.43923484 -0.09119431 0.32772465 0.34325338 0.01731712 -0.28073798 0.39537496 0.09365181 -0.24057869 -0.5238085 -0.3035102 0.53520429 0.94732342 -0.40593518 -0.37112931 -0.0610225 0.26211594 0.51096725 -0.74657876 -0.4668039 0.34383364 0.65990638 -0.67455365 -0.20302455 -0.51223175 0.20865335 0.31091778 -0.3855612 -0.58707168 0.21290637 0.28386365 0.25445908 -0.42757652 -0.34554999 0.57824806 0.56947678 -0.44043856 -0.59497373 -0.19046726 0.78359797 0.125395 0.01909045 -1.25379069 -0.09729798 0.52626197 0.78733424 -0.54835847 -0.47638112 -0.07003016 0.55939806 1.16409273 -0.0810496 -0.18461299 0.41337285 0.72340257 0.47537153 0.11145316 -0.41716581 0.15447172 0.87950718 0.32799822 -0.72525093 -0.25424443 -0.33243891 0.89624186 -0.24327463 -0.377505 -0.01318703 1.15073861 0.50827694 0.14629782 -0.60745337 0.35594258 0.77265696 0.51980829 -0.43604754 0.19361863 0.0974694 0.12374675 0.22393652 -0.25111504 -0.16791473 0.66888136 0.08905014 -0.24185122 -0.82934214 0.17298365 0.32383379 0.38730725 -0.55691312 -0.14960641 -0.3161664 1.00423863 -0.13530144 0.2758329 -0.59409022 -0.72711962 0.18561096 0.29493483 -0.49462417 -0.02535275 -0.32179269 0.63802358 0.06450911 -0.36244535 -0.55088169 0.47010579 -0.03932424 -0.05139748 -0.72489824 0.43677258 0.85363747 0.59513256 -1.1427693 -0.75490234 -0.05380666 0.84642801 0.97061214 -0.82256622 -1.12268162 -0.11974293 0.25058075 -0.14730279 -0.41490229 0.47094733 0.0695535 -0.06111872 -0.00325791 -0.69918284 0.97462969 0.10417971 -0.06695869 -1.23309132 -0.17049135 0.64043296 0.82727541 -0.20828416 -0.59323465 -0.65802288 0.32621394 0.5368197 0.37921229 -1.08605397 0.16858299 0.03444726 0.11315069 0.05051093 0.03860219 -0.35531796 0.3553949 0.39874088 -0.52344943 -0.13202249 0.91263459 0.32986441 0.26566883 -0.62952324 -0.54520924 -0.43928257 1.0950506 0.1665704 -1.02249691 -0.05817481 -0.30783025 0.09503854 0.06272448 -0.35042346 0.06067587 0.08451991 0.3850205 -0.77288649 0.17066585 0.10336318 0.37866533 -0.63292289 -0.15179168 0.06741788 0.41384271 -0.29224392 0.39719698 -1.22197233] Knowledge numpy.linalg.solve(a, b) to calculate the result of ax = b Exercise 9.3: NormsCompute the Frobenius norm of A: |A|F and the infinity norm of B: |B|∞. Also find the largest and smallest singular values of B. Code12345678910A_FN = numpy.linalg.norm(A, 'fro')B_IN = numpy.linalg.norm(B, numpy.inf)print("---------- A_FN ------------\n"+str(A_FN))print("---------- B_IN ------------\n"+str(B_IN))U, sigma, V = numpy.linalg.svd(B)B_max_singular = numpy.max(sigma)B_min_singular = numpy.min(sigma)print("---------- B_max_singular ------------\n"+str(B_max_singular))print("---------- B_min_singular ------------\n"+str(B_min_singular)) Result12345678---------- A_FN ------------316.813378033---------- B_IN ------------387.19726512---------- B_max_singular ------------51.6474766426---------- B_min_singular ------------0.0562452006537 Knowledge 矩阵范数：norm, numpy.linalg.norm() 奇异值分解：singular values， numpy.linalg.svd() Exercise 9.4: Power iterationGenerate a matrix Z, n × n, with Gaussian entries, and use the power iteration to find the largest eigenvalue and corresponding eigenvector of Z. How many iterations are needed till convergence? Optional: use the time.clock() method to compare computation time when varying n. Code1234567891011121314151617181920212223242526272829import timeZ = numpy.random.normal(size=[n, n])def power_iteration_eigenvalue( X, err=0.01): x = numpy.random.normal(size=len(X)).transpose() step = numpy.inf times = 0 time_begin = time.clock() while step &gt; err: old = numpy.max(x) x = x/old x = numpy.matmul(X, x) new = numpy.max(x) step = abs(old-new) times += 1 # print("step "+str(times)+" : "+str(new)) time_end = time.clock() return x, new, times, time_end-time_begin[eigenvector, eigenvalue, times, running_time] = power_iteration_eigenvalue(Z)print("------------ E_9_4 ----------------")print("eigenvector: "+str(eigenvector))print(" eigenvalue: "+str(eigenvalue))print(" step count: "+str(times))print(" time used: "+str(running_time)) Result123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354------------ E_9_4 ----------------eigenvector: [ 6.19366521e+00 -7.19111305e+00 7.47822455e+00 1.76596816e+00 -1.22108278e+01 -6.68997718e+00 -1.07959431e+01 7.38413171e+00 9.60996846e+00 -3.39415864e+00 -1.23836889e+01 1.60311426e+01 -3.55845284e-01 -1.69182976e+01 6.50582275e+00 -3.93769884e+00 7.23395058e+00 -6.30992140e+00 3.77506490e+00 -3.23313667e+00 6.64974007e+00 -7.24150321e+00 9.88020162e+00 2.08854412e-03 3.07409841e+00 3.42129651e+00 -5.92382223e+00 -1.35043015e+00 -1.40770229e+00 1.24531978e+01 -6.32025548e+00 -1.26441627e+01 3.26831772e-01 -1.42739520e+00 1.32925887e+00 1.06598272e+01 -8.48197449e+00 4.82646327e+00 3.67864359e+00 -2.92456117e+00 1.49065221e+01 -3.89251672e+00 1.24128342e+01 1.27677631e+01 -1.11263113e+01 -1.46350312e+01 9.36651121e+00 -3.84124488e-01 -5.67795245e+00 -8.75638867e+00 6.02814460e+00 -9.83530958e-01 6.50873016e+00 9.18944025e+00 -1.08015910e+01 -2.27073094e+00 2.05116066e+00 9.74180888e+00 4.34640807e+00 -1.45355560e+00 1.72229371e+00 1.60129994e+00 -9.49922896e+00 -9.26528224e+00 1.41245323e+01 1.29324148e+00 1.15170129e+01 -2.78286401e+00 -2.41103992e+00 -6.04664999e+00 1.60510520e+01 9.06866735e+00 -2.39722406e+00 -7.74249726e+00 -6.22329381e+00 5.66999289e+00 7.07244637e-01 -1.42750525e+01 1.00944549e+01 -1.56414851e-01 -6.77685962e+00 -1.31324847e+00 1.40962962e+01 -2.82314517e+00 1.15847925e+00 -1.45499963e+01 -1.47587123e+00 -5.45102517e+00 2.07919993e+00 1.48515566e+00 -3.34405736e+00 -4.93831256e-01 3.52542969e+00 -4.49030531e+00 -4.14344570e+00 -6.73085059e+00 -1.96366164e+00 -4.73358636e+00 -1.42491876e+01 7.14478669e-01 -4.03345293e+00 -8.64438839e-01 -1.91710524e+00 4.02300501e-01 -3.12336156e+00 3.25908960e+00 8.73984942e+00 1.80387754e+00 5.37126471e-01 2.33427637e-01 7.20753102e+00 8.38898454e+00 6.73706722e+00 2.25368920e+00 4.03456123e+00 -5.26635000e-01 -1.09389778e+01 -1.69632014e+01 -5.04630146e+00 2.99535217e+00 -4.97695971e+00 7.08832858e+00 -1.42509689e+00 5.44444010e-01 1.14700391e+00 -3.34913269e+00 -1.68841359e+00 -1.85218648e+00 6.17064696e+00 -1.17127043e+00 -7.25388347e+00 -2.70293145e+00 -8.28104371e+00 1.64055792e+00 4.94486141e+00 4.18690047e+00 -9.94856800e+00 -8.29269461e+00 5.81317629e+00 -1.31414167e+01 8.10423657e-01 -1.30089443e+01 -7.10088385e+00 -7.62918634e+00 5.14150493e+00 4.43537243e+00 -3.52960575e-01 -1.35215797e+00 -5.68239918e+00 -5.78998103e+00 -4.91632266e-01 -2.68038511e+00 -1.03668811e+01 5.49950249e+00 -2.26436209e+00 1.23865979e+01 6.14732355e+00 4.31623361e+00 -8.40648179e+00 -3.72063488e+00 2.01815136e+00 -5.14877954e-01 -1.16816147e+00 -2.24455122e+01 -5.57878300e+00 3.10970510e-01 1.29690655e+00 -1.69972653e+01 1.58677609e+01 -5.77551543e+00 -4.36274195e+00 -5.63981586e+00 -4.54383986e+00 -7.16379461e-01 -4.07212591e+00 -5.45036929e+00 -9.33501142e+00 -1.46760018e+01 -4.31132630e+00 1.16448053e+01 6.21216923e+00 -6.78022246e+00 4.13536082e+00 3.69218241e+00 1.97466803e+00 -1.08666389e+00 8.80475201e+00 2.46159249e+00 2.21402112e+00 -2.46765512e+00 3.57973968e+00 -1.11716056e-01 -8.24346370e+00 -2.90508233e+00 4.13721878e+00 -4.10881873e+00 5.15073997e+00 -1.22542384e+01 3.96149388e+00 -1.13627510e+01] eigenvalue: 16.0510519646 step count: 68 time used: 0.007216 Knowledge eigenvalue: 特征值 幂迭代法：x(k) = x(k-1)*A Exercise 9.5: Singular valuesGenerate an n × n matrix, denoted by C, where each entry is 1 with probability p and 0 otherwise. Usethe linear algebra library of Scipy to compute the singular values of C. What can you say about therelationship between n, p and the largest singular value? Code12345678p = 0.1print("-------------- E_9_5 ------------------")while p&lt;1: C = numpy.random.binomial(1, p, [n, n]) U, singular_value, V = numpy.linalg.svd(C) max_singular = numpy.max(singular_value) print("n= "+str(n)+" p= "+str(p)+" max_singular= "+ str(max_singular)) p += 0.1 Result1234567891011-------------- E_9_5 ------------------n= 200 p= 0.1 max_singular= 20.6567657213n= 200 p= 0.2 max_singular= 40.4920520455n= 200 p= 0.3 max_singular= 60.6782510601n= 200 p= 0.4 max_singular= 81.0362830637n= 200 p= 0.5 max_singular= 101.14764207n= 200 p= 0.6 max_singular= 120.373897161n= 200 p= 0.7 max_singular= 139.768077408n= 200 p= 0.8 max_singular= 160.37471516n= 200 p= 0.9 max_singular= 179.191890776n= 200 p= 1.0 max_singular= 200.0 Knowledge random.binomial(n, p, size), n is 0~n, p is probability, size is size we can find that max_singular = n * p Exercise 9.6: Nearest neighborWrite a function that takes a value z and an array A and finds the element in A that is closest to z. Thefunction should return the closest value, not index. Hint: Use the built-in functionality of Numpy rather than writing code to find this value manually. Inparticular, use brackets and argmin. Code123456789def closest( X, z): ind = numpy.argmin(numpy.abs(X - z * numpy.ones((len(X), len(X[0]))))) return X[ind//len(X[0])][ind%len(X[0])]print("-------------- Closest ---------------")z = -1while z &lt;= 1: print("z= "+str(z)+" closest= "+str(closest(A, z))) z += 0.1 Result12345678910111213141516171819202122-------------- Closest ---------------z= -1 closest= -1.00000868018z= -0.9 closest= -0.899991177575z= -0.8 closest= -0.799982994952z= -0.7 closest= -0.699995902891z= -0.6 closest= -0.59999964816z= -0.5 closest= -0.499995702358z= -0.4 closest= -0.399997886746z= -0.3 closest= -0.299999122356z= -0.2 closest= -0.200002337307z= -0.1 closest= -0.0999872558528z= -1.38777878078e-16 closest= -1.45838021333e-05z= 0.1 closest= 0.10001924864z= 0.2 closest= 0.200009578588z= 0.3 closest= 0.30001507798z= 0.4 closest= 0.399992197442z= 0.5 closest= 0.499998597393z= 0.6 closest= 0.599983955592z= 0.7 closest= 0.700043443047z= 0.8 closest= 0.800006259776z= 0.9 closest= 0.900013425609z= 1.0 closest= 1.00000424317 Knowledge argmin(X) to return X’s minimum’s index Reference]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[星球的公转与自转]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%98%9F%E7%90%83%E7%9A%84%E5%85%AC%E8%BD%AC%E4%B8%8E%E8%87%AA%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[星球公转与自转 更新：将公转矩阵与摄像机矩阵分离，公用变换（摄像机、透视）与各个物体的单独变换分离，使代码更符合逻辑。 环境说明 开发环境：Linux 运行环境：Linux 运行方式： 打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./planet_rotation 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 附有运行成功的demo，可以作为参考 使用库：GLFW、GLEW、GLM 运行结果 ESC：退出程序 D：按下后逆时针自转 shift+D：顺时针自转 Y：按下后逆时针公转 shift+Y：顺时针公转 方向键：旋转观察视角 公转与自转： 改变旋转方向： 更改观察视角 实现过程 生成球体： 生成顶点：遍历每个纬度、经度，计算纬度、经度映射到球体上的坐标 生成球面三角：在北极点与南极点处，与相邻纬度生成三角；在其余纬度上，与相邻纬度生成四边形（即两个三角） 生成缓冲区：将生成的球体顶点与顶点索引绑定至缓冲区，VAO分别为SUM和PLANET，代表大球（太阳）及小球（行星） 生成着色器 绘制：View作为摄像机视角，Projection为透视矩阵，这二者为全局公用。 按处理对象，分为两种矩阵——公共矩阵及单个模型的矩阵； self_trans设为小球的旋转矩阵，管理自转； position_trans设为小球的轨道初始坐标 public_trans设为小球的坐标矩阵，管理公转； 按照mvp = Projection * View * public_trans * position_trans * self_trans;顺序管理小球——先自转，再移动，后以透视视角形变。 分别绑定两个缓冲区，分别绘制两个星球。 交互：设置键盘事件，管理自转与公转的旋转角度 ESC：退出程序 D：按下后逆时针自转 shift+D：顺时针自转 Y：按下后逆时针公转 shift+Y：顺时针公转 方向键：旋转观察视角 知识点 多个物体绘制: 当多个物体需要绘制时，每个物体有自己的顶点缓冲区、顶点索引缓冲区，因此为每一个物体设置一个顶点数组（VAO），此后每次需要此物体时，直接绑定该顶点数组，同时绑定内部的数据格式。 球体生成： 遍历球体的每个纬度、经度，通过三角函数运算得到对应经纬度的正交右手系坐标: 12345678910111213for (unsigned int i=0; i &lt;= HorSlide; i++)&#123; float hor_angle = hor_step * i; float z_cur = radius * cos(hor_angle); //z原点坐标 float r_cur = radius * sin(hor_angle); //纬度平面半径 for (unsigned int j=0; j &lt;= VerSlide; j++)&#123; float ver_angle = j*ver_step; float x_cur = r_cur * cos(ver_angle); //顶点入vector vects.push_back(x_cur+x); vects.push_back(y_cur+y); vects.push_back(z_cur+z);... ... 并对每个相邻的纬度生成球面三角: 12345678910111213141516171819202122232425262728//插入球面三角形顶点索引if (i &gt; 0 &amp;&amp; j &gt; 0)&#123; //若以自我为一个四边形的右下角，其绘制曲面三角的点： unsigned int ru = index - VerSlide; unsigned int lu = index - VerSlide - 1; unsigned int ld = index -1; unsigned int rd = index; //上或下一圈为一个点，添加的为三角形 if (i == 1)&#123; inds.push_back(ru); inds.push_back(ld); inds.push_back(rd); &#125; else if (i == HorSlide)&#123; inds.push_back(ru); inds.push_back(lu); inds.push_back(rd); &#125; //四边行情况——添加两个三角形 else&#123; inds.push_back(ru); inds.push_back(ld); inds.push_back(rd); inds.push_back(ru); inds.push_back(lu); inds.push_back(ld); &#125;&#125; 旋转变换： 公转：通过旋转摄像机函数，得到公转的效果，同时反向等速旋转大球，使其独立于公转不旋转： 12View = glm::rotate(View, glm::radians(public_rotate), glm::vec3(0, 0, 1.0f)); //旋转视角以公转model = glm::rotate(model, glm::radians(-public_rotate), glm::vec3(0, 0, 1.0f)); //旋转大球以让大球看起来静止 自转：在绘制完大球后，绑定小球缓冲区，并计算自传的变换矩阵。其中，最关键的是 绕任意轴旋转: 将小球移动至原点 在原点对小球进行旋转 将小球移动回自己的轨迹 生成变换矩阵，绘制。123456789101112131415161718glBindVertexArray(PLANET);planet_self = planet_self + self_rotate;if (planet_self &gt; 360) planet_self -= 360;else if (planet_self &lt; 0) planet_self += 360;planet_public = (planet_public + public_rotate);if (planet_public &gt; 360) planet_public -= 360;else if (planet_public &lt; 0) planet_public += 360;glm::mat4 public_trans = glm::rotate(model, glm::radians(planet_public), glm::vec3(0, 0, 1));glm::mat4 position_trans = glm::translate(model, position);glm::mat4 self_trans = glm::rotate(model, glm::radians(planet_self), glm::vec3(0, 0, 1));mvp = Projection * View * public_trans * position_trans * self_trans;glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(mvp));glDrawElements(GL_LINE_STRIP, indsP.size(), GL_UNSIGNED_INT, (void*)0); // we use index buffer, so set it to null. 按键交互：转自 1234567891011key include/GLFW/glfw3.h 中定义的 GLFW_KEY_* 包含一些按键的ASCII码scancdeaction 按键动作GLFW_RELEASE 松开GLFW_PRESS 按下GLFW_REPEAT 重复，一直按着mods 按键模式GLFW_MOD_SHIFT 按下Shift键GLFW_MOD_CONTROL 按下Ctrl键GLFW_MOD_ALT 按下Alt键GLFW_MOD_SUPER 实验过程 最后一个顶点总在原点——总有个“小尾巴”与原点相连 index算错，整体向后偏移一个，因此最后一个index对应的点在原点，更改后： 生成圆时ｚ坐标偏移出错:输出坐标发现，z的坐标在不断叠加： 12345678910-8.74228e-08 0 0-8.63465e-08 -1.36759e-08 1-8.3144e-08 -2.70151e-08 2-7.78943e-08 -3.96891e-08 3-7.07265e-08 -5.13858e-08 4-6.18172e-08 -6.18172e-08 5-5.13858e-08 -7.07265e-08 6-3.96891e-08 -7.78943e-08 7-2.70151e-08 -8.3144e-08 8-1.36759e-08 -8.63465e-08 9 原来是z坐标没有在纬度平面上循环时重置……12345678//根据原点坐标，进行平移x_cur += x;y_cur += y;z_cur += z;//顶点入vector vects.push_back(x_cur);vects.push_back(y_cur);vects.push_back(z_cur); 改为以下即可：123vects.push_back(x_cur+x);vects.push_back(y_cur+y);vects.push_back(z_cur+z); 源代码参考资料球体生成 按键]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenGL 旋转彩色立方体]]></title>
    <url>%2F2018%2F05%2F10%2FOpenGL-%E6%97%8B%E8%BD%AC%E5%BD%A9%E8%89%B2%E7%AB%8B%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[彩色旋转立方体环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/Cubic文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./cubic 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM 知识点 矩阵变换 矩阵的变换分为三种：放缩、旋转、平移，三者顺序不应混乱，用矩阵乘法表示： 1glm::mat4 mvp = Projection * View * model; 在本次实验中，使用的是透视视角，即近大远小，使用projection函数可以生成透视变换视角，属于放缩变换： 1glm::mat4 Projection = glm::perspective(glm::radians(90.0f), (float) width / (float)height, 0.1f, 100.0f); 为了让矩阵旋转，我们首先预设摄像机位置： 12345glm::mat4 View = glm::lookAt( glm::vec3(4,3,3), // Camera is at (4,3,3), in World Space glm::vec3(0,0,0), // and looks at the origin glm::vec3(0,1,0) // Head is up (set to 0,-1,0 to look upside-down)); 再于每次渲染改变角度（旋转矩阵）： 1View = glm::rotate(View, glm::radians(1.0f), glm::vec3(-1.0f, -1.0f, 1.0f)); 着色器： 着色器分类：本次实验中用到像素着色器与顶点着色器，顶点着色器用于将外部的顶点信息打包给其他着色器绘制，像素着色器用于染色。 着色器使用GLSL语言进行编写，并在C++中用字符串形式进行输入： 1234567891011//顶点着色器 const GLchar* vertexShaderSource="#version 330 core\n" "layout (location=0) in vec3 aPos;\n" "layout (location=1) in vec3 vertexColor;\n" "out vec3 fragmentColor;\n" "uniform mat4 transform;\n" "void main()\n" "&#123;\n" "gl_Position = transform * vec4(aPos, 1.0);\n" "fragmentColor = vertexColor;\n" "&#125;\0"; 着色器的编译与测试： 1234567891011int vertexShader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader);GLint success; GLchar infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) &#123; glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; 着色器链接： 123456789int shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) &#123; glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl; &#125; 着色器参数属性： 123glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 将变换矩阵传入着色器的uniform变量中： 12unsigned int transformLoc = glGetUniformLocation(shaderProgram, "transform");glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(mvp)); 深度测试：若不开启深度测试，会导致着色器无法判断覆盖信息，深度测试的用途是用于舍弃被遮盖住的图像，使其更加真实： 12glEnable(GL_DEPTH_TEST);glDepthFunc(GL_LESS); 源码结果 注意事项 本环境中未配置glad，而使用glew，在代码开始时注意此初始化顺序： 123456789101112131415glfwInit();//初始化 // Set all the required options for GLFW glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置主版本号 glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置次版本号 glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Create a GLFWwindow object that we can use for GLFW's functions 创建一个窗口 GLFWwindow* window = glfwCreateWindow(800, 600, "The perspective projection", NULL, NULL); glfwMakeContextCurrent(window);//设置为当前窗口 // Set this to true so GLEW knows to use a modern approach to retrieving function pointers and extensions glewExperimental = GL_TRUE; // Initialize GLEW to setup the OpenGL Function pointers glewInit(); 否则会导致此错误： 1Segmentation fault (core dumped) 若提示./cubic command not found则先chmod u+x cubic 在未配置opengl环境的电脑上运行时可能缺少动态链接库，因此将动态链接库打包于项目文件中的dll文件夹，使用时需要用 1export LD_LIBRARY_PATH=xxx 增加动态链接库搜索位置，其中xxx为dll文件夹。 参考来源绘制旋转立方体 规范代码 透视教程 录屏转gif 动态库链接]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello OpenGL]]></title>
    <url>%2F2018%2F05%2F07%2FHello-OpenGL%2F</url>
    <content type="text"><![CDATA[VSCode + GLFW + GLEW 在ubuntu下的安装环境说明 开发环境：Linux 运行环境：Linux 运行方式： 首先在/HelloOpenGL文件夹（本文件夹）下打开终端，用export LD_LIBRARY_PATH=./../dll，增加动态库搜索路径 运行可执行文件./helloOpenGL 若失败，则按照GLFW、GLEW的配置方法配置好环境后在本机重新编译 使用库：GLFW、GLEW、GLM安装OpenGL（包括GLUT）：123sudo apt-get install build-essential libgl1-mesa-devsudo apt-get install freeglut3-devsudo apt-get install libglew-dev libsdl2-dev ibsdl2-image-dev libglm-dev libfreetype6-dev GLFW： 去官网下载源码 编译安装： 安装cmake: sudo apt-get install cmake 解压刚刚下载的源码: sudo unzip xxx.zip -d glfw，其中xxx为你刚刚下载的压缩包名 进入解压后的GLFW根目录（含有include、CMake的那个），进行安装: 123sudo cmake .sudo makesudo make install GLEW： 查看glew：sudo apt-cache search glew 将显示的内容用sudo apt-get install xxx下载下来，其中xxx为要下载的内容 编译1g++ -o helloOpenGL helloOpenGL.cpp -lGL -lGLU -lglut -lglfw3 -lX11 -lXrandr -lXinerama -lXi -lXxf86vm -lXcursor -lpthread -lGLEW -ldl 实例源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;using namespace std;// Is called whenever a key is pressed/released via GLFW void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode) &#123; if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) glfwSetWindowShouldClose(window, GL_TRUE); &#125; int main(void)&#123; GLFWwindow* window; /* Initialize the library */ if (!glfwInit()) return -1; /* Create a windowed mode window and its OpenGL context */ window = glfwCreateWindow(800, 600, "The First Opengl Program", NULL, NULL); if (!window) &#123; glfwTerminate(); return -1; &#125; // Set the required callback functions 设置事件回调函数 glfwSetKeyCallback(window, key_callback); /* Make the window's context current */ glfwMakeContextCurrent(window); /* Loop until the user closes the window */ while (!glfwWindowShouldClose(window)) &#123; /* Draw a triangle */ glBegin(GL_QUAD_STRIP); glVertex3f(0.5, 0.5, 0.0); glVertex3f(0.5, -0.5, 0.0); glVertex3f(-0.5, 0.5, 0.0); glVertex3f(-0.5, -0.5, 0.0); glEnd(); /* Swap front and back buffers */ glfwSwapBuffers(window); /* Poll for and process events */ glfwPollEvents(); &#125; glfwTerminate(); return 0;&#125; 效果 注意事项 GLEW应该在GLFW、GLUT等之前include。 要加上-ldl，否则会出现错误： 12/usr/bin/x86_64-linux-gnu-ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol 'dlclose@@GLIBC_2.2.5'//lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line 由于很多教程基于GLUT，又有很多教程基于GLFW、GLEW，因此编译连接了大部分可能用到的库 若不调用GLEW，很有可能造成shader的许多问题 参考来源：关于GLEW的错误 GLFW的安装 GLEW的安装 OpenGL下载安装+GLEW的include顺序问题 OpenGL环境配置 渲染器 绘制demo]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业08 LeetCode #213 #120]]></title>
    <url>%2F2018%2F04%2F29%2FPython%E4%BD%9C%E4%B8%9A08-LeetCode-213-120%2F</url>
    <content type="text"><![CDATA[213 House Robber II原题After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 题意分析给出一个循环数列（即第一个数与最后一个数相邻），不允许取相邻的数字，求取出数字和的最大值。 题目思路用动态规划。首先由于是循环数列，因此第一个与最后一个不能同时取到（但可以同时不取到），因此我们分别删除第一个和最后一个进行计算，消除循环队列的影响。由于不能取到两个相邻的数字，因此可以得到状态转移方程： F(k) = max(F(k-2)+num[k], F(k-1)) 补充边界： F(0) = num[0] F(1) = max(num[0], num(1)) 注意，上述的num数列已经是剔除第一或最后一个数字的数列。 代码（python）123456789101112131415161718192021class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums)==0: return 0 if len(nums)==1: return nums[0] tmp = nums.pop(0) last, now = 0, 0 for i in nums: last, now = now, max(last+i, now) r1 = now nums.insert(0, tmp) nums.pop() last, now = 0, 0 for i in nums: last, now = now, max(last+i, now) return max(r1, now) 结果 120 Triangle原题Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题意分析在给出的数字三角形中，从顶向下找出一条数字和最小的路径，计算其最小数字和。 题目思路动态规划，维护一个列表储存上一层（较长的一层，在本题中是下一层）选择各个节点的结果，给出下列状态转移方程（i为行，j为列）： F(0,j) = list(0,j) F(i,j) = max(F(i-1, j)+list(i,j), F(i-1, j+1)+list(i,j)) 由于仅需要上一层第j个和第j+1的信息，因此可以维持一个一维列表即可满足——每次从左至右更新放至列表的第j位。 代码（python）1234567891011class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ res = triangle.pop() for l in reversed(triangle): for i in range(len(l)): res[i] = min(res[i]+l[i], res[i+1]+l[i]) return res[0] 结果]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业06代码测试]]></title>
    <url>%2F2018%2F04%2F15%2Fpython%E4%BD%9C%E4%B8%9A06%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Description (test)Select from exercise 11-1 to 11-3 Code (test)11-1in city_functions.py:12def city_functions( city, country): return city+', '+country in test module:12345678910111213# 11-1 城市和国家 ：编写一个函数，它接受两个形参：一个城市名和一个国家名。这个函数返回一个格式为City, Country 的字符串，# 如Santiago, Chile 。将这个函数存储在一个名为city_functions.py的模块中。创建一个名为test_cities.py的程序，对刚编写的函# 数进行测试（别忘了，你需要导入模块unittest 以及要测试的函数）。编写一个名为test_city_country() 的方法，核实使用类似于# 'santiago' 和'chile' 这样的值来调用前述函数时，得到的字符串是正确的。运行test_cities.py ，确认测试test_city_country() 通过了。import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') result:12345678Testing started at 13:15 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --path D:/pyproject/homework1/11-1.pyRan 1 test in 0.001sOKLaunching unittests with arguments python -m unittest D:/pyproject/homework1/11-1.py in D:\pyproject\homework1 11-2 修改前面的函数，使其包含第三个必不可少的形参population ，并返回一个格式为City, Country - population xxx 的字符串，如Santiago, Chile - population 5000000 。运行test_cities.py，确认测试test_city_country() 未通过。 in city_functions.py:12def city_functions( city, country, population): return city + ', ' + country + ' - population ' + str(population) in test module:12345678import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') result:123456789101112131415161718192021Testing started at 13:25 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --target 11-2.CityCountryTestCase.test_city_functionsLaunching unittests with arguments python -m unittest 11-2.CityCountryTestCase.test_city_functions in D:\pyproject\homework1Ran 1 test in 0.004sFAILED (errors=1)ErrorTraceback (most recent call last): File "C:\Users\lenovo\AppData\Local\Programs\Python\Python36-32\lib\unittest\case.py", line 59, in testPartExecutor yield File "C:\Users\lenovo\AppData\Local\Programs\Python\Python36-32\lib\unittest\case.py", line 601, in run testMethod() File "D:\pyproject\homework1\11-2.py", line 12, in test_city_functions res = city_functions('Santiago', 'Chile')TypeError: city_functions() missing 1 required positional argument: 'population'Process finished with exit code 1 修改上述函数，将形参population 设置为可选的。再次运行test_cities.py，确认测试test_city_country() 又通过了。再编写一个名为test_city_country_population() 的测试，核实可以使用类似于&#39;santiago&#39; 、&#39;chile&#39; 和&#39;population=5000000&#39; 这样的值来调用这个函数。再次运行test_cities.py，确认测试test_city_country_population() 通过了。 in city_functions.py:12345def city_functions( city, country, population=-1): if population == -1: return city + ', ' + country else: return city + ', ' + country + ' - population ' + str(population) in test module:123456789101112import unittestfrom city_functions import city_functionsclass CityCountryTestCase( unittest.TestCase): def test_city_functions(self): res = city_functions('Santiago', 'Chile') self.assertEqual(res, 'Santiago, Chile') def test_city_functions_population(self): res = city_functions('Santiago', 'Chile', 500000) self.assertEqual(res, 'Santiago, Chile - population 500000') result:12345678910Testing started at 13:34 ...D:\pyproject\homework1\venv\Scripts\python.exe "C:\Program Files\JetBrains\PyCharm Community Edition 2017.3.3\helpers\pycharm\_jb_unittest_runner.py" --path D:/pyproject/homework1/11-2.pyLaunching unittests with arguments python -m unittest D:/pyproject/homework1/11-2.py in D:\pyproject\homework1Ran 2 tests in 0.001sOKProcess finished with exit code 0]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业05类&文件&异常]]></title>
    <url>%2F2018%2F04%2F08%2Fpython%E4%BD%9C%E4%B8%9A05%E7%B1%BB%E4%B8%8E%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Description (class)Select from exercise 9-1 to 9-15 Code (class)9-3123456789101112131415161718192021# 9-3 用户 ：创建一个名为User 的类，其中包含属性first_name 和last_name ，# 还有用户简介通常会存储的其他几个属性。在类User 中定义一个名# 为describe_user() 的方法，它打印用户信息摘要；再定义一个名为greet_user() 的方法，它向用户发出个性化的问候。# 创建多个表示不同用户的实例，并对每个实例都调用上述两个方法。class User(): def __init__(self, first_name, last_name): self.first_name = first_name.title() self.last_name = last_name.title() def describe_user(self): print(self.first_name+" "+self.last_name) def greet_user(self): print("Hello "+self.first_name+" "+self.last_name+"! ")users = [User("kate", "snow"), User("jone", "ossaki"), User("lin", "li")]for u in users: u.describe_user() u.greet_user() result:123456Kate SnowHello Kate Snow! Jone OssakiHello Jone Ossaki! Lin LiHello Lin Li! 9-5123456789101112131415161718192021222324class User(): def __init__(self, first_name, last_name): self.first_name = first_name.title() self.last_name = last_name.title() self.login_attempts = 0--snip-- def increment_login_attempts(self): self.login_attempts += 1 def reset_login_attempts(self): self.login_attempts = 0# 9-5 尝试登录次数 ：在为完成练习9-3而编写的User 类中，添加一个名为login_attempts 的属性。编写一个名为increment_login_attempts() 的方法，# 它将属性login_attempts 的值加1。再编写一个名为reset_login_attempts() 的方法，它将属性login_attempts 的值重置为0。# 根据User 类创建一个实例，再调用方法increment_login_attempts() 多次。打印属性login_attempts 的值，确认它被正确地递增；然后，调用方# 法reset_login_attempts() ，并再次打印属性login_attempts 的值，确认它被重置为0。test = User("King", "Kong")test.increment_login_attempts()test.increment_login_attempts()test.increment_login_attempts()print(test.login_attempts)test.reset_login_attempts()print(test.login_attempts) result:1230 9-71234567891011121314151617# 9-7 管理员 ：管理员是一种特殊的用户。编写一个名为Admin 的类，让它继承你为完成练习9-3或练习9-5而编写的User 类。# 添加一个名为privileges 的属性，用于存储一个由字符串（如"can add post" 、"can delete post" 、"can ban user" 等）# 组成的列表。编写一个名为show_privileges() 的方法，它显示管理员的权限。创建一个Admin 实例，并调用这个方法。class Admin(User): def __init__(self, first_name, last_name): super().__init__(first_name, last_name) self.privileges = ["can add post", "can delete post", "can ban user"] def show_privileges(self): for p in self.privileges: print(p)admin_test = Admin("Briiza", "Chen")admin_test.show_privileges() result:123can add postcan delete postcan ban user 9-111234567# 9-11 导入Admin 类 ：以为完成练习9-8而做的工作为基础，将User 、Privileges 和Admin 类存储在一个模块中，# 再创建一个文件，在其中创建一个Admin 实例并对其调用方法show_privileges() ，以确认一切都能正确地运行。import ninetest_import = nine.Admin("Buluce","Xiang")test_import.show_privileges() nine is the module define User and Adminresult:1234can add postcan delete postcan ban user Description (file)Select from exercise 10-1 to 10-16 Code (files)10-1123456789101112131415161718# 10-1 Python学习笔记 ：在文本编辑器中新建一个文件，写几句话来总结一下你至此学到的Python知识，# 其中每一行都以“In Python you can”打头。将这个文件命名为learning_python.txt，# 并将其存储到为完成本章练习而编写的程序所在的目录中。编写一个程序，它读取这个文件，并将你所写的内容打印三次：# 第一次打印时读取整个文件；第二次打印时遍历文件对象；第三次打印时将各行存储在一个列表中，再在with 代码块外打印它们。with open('learning_python.txt') as file_obj: content = file_obj.read() print(content)with open('learning_python.txt') as file_obj: for item in file_obj: print(item)with open('learning_python.txt') as file_obj: lines = file_obj.readlines()for line in lines: print(line) result:12345678910111213In Python you can code.In Python you can create a game.In Python you can use loop.In Python you can code.In Python you can create a game.In Python you can use loop.In Python you can code.In Python you can create a game.In Python you can use loop. 10-41234567891011121314# 10-4 访客名单 ：编写一个while 循环，提示用户输入其名字。用户输入其名字后，在屏幕上打印一句问候语，# 并将一条访问记录添加到文件guest_book.txt中。确保这个文件中的每条记录都独占一行。with open('guest_book.txt', 'a') as file_obj: while(1): name = input("Input your name(q to quit): ") if ( name == "q"): break print("Hello "+name+" !") file_obj.write(name+"\n")with open('guest_book.txt','r') as read_obj: context = read_obj.read() print(context) result:12345678910Input your name(q to quit): wangHello wang !Input your name(q to quit): heyHello hey !Input your name(q to quit): juneHello june !Input your name(q to quit): qwangheyjune 10-6 10-7123456789101112131415161718# 10-6 加法运算 ：提示用户提供数值输入时，常出现的一个问题是，用户提供的是文本而不是数字。在这种情况下，# 当你尝试将输入转换为整数时，将引发TypeError 异常。编写一个程序，提示用户输入两个数字，再将它们相加并打印结果。# 在用户输入的任何一个值不是数字时都捕获TypeError 异常，并打印一条友好的错误消息。对你编写的程序进行测试：先输入两个数字，# 再输入一些文本而不是数字。# 10-7 加法计算器 ：将你为完成练习10-6而编写的代码放在一个while 循环中，让用户犯错（输入的是文本而不是数字）后能够继续输入数字。while (1): a = input("Input 2 num, q to quit:") b = input() if (a=='q' or b=='q'): break try: aa = int(a) bb = int(b) except: print("Hey, error input, try again...") else: print(aa+bb) result:12345678Input 2 num, q to quit:abHey, error input, try again...Input 2 num, q to quit:235Input 2 num, q to quit:qf]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业04-输入&函数]]></title>
    <url>%2F2018%2F03%2F29%2Fpython%E4%BD%9C%E4%B8%9A04-%E8%BE%93%E5%85%A5-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description (input)Select from exercise 7-1 to 7-10 Code (input)7-31234567# 7-3 10的整数倍 ：让用户输入一个数字，并指出这个数字是否是10的整数倍。for i in range(1, 4): num = int(input("Enter a number: ")) if (num % 10 == 0): print("Yes") else: print("No") result:123456789Enter a number: 120YesEnter a number: 3NoEnter a number: fTraceback (most recent call last): File "D:/pyproject/homework1/7.py", line 3, in &lt;module&gt; num = int(input("Enter a number: "))ValueError: invalid literal for int() with base 10: 'f' 7-712345# 7-7 无限循环 ：编写一个没完没了的循环，并运行它（要结束该循环，可按Ctrl +C，也可关闭显示输出的窗口）。i = 0while(1): print(i) i = i+1; result:1234123... 7-1012345678910# 7-10 梦想的度假胜地 ：编写一个程序，调查用户梦想的度假胜地。使用类似于“If you could visit one place in the world,# where would you go?”的提示，并编写一个打印调查结果的代码块。cities = []for i in range(0, 10): where = input("If you could visit one place in the world, where would you go?") cities.append(where)for city in set(cities): print(city+": ") print(cities.count(city)) result:12345678910111213141516171819202122If you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?AmericaIf you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?TokyoIf you could visit one place in the world, where would you go?KyotoIf you could visit one place in the world, where would you go?TokyoIf you could visit one place in the world, where would you go?ShanghaiIf you could visit one place in the world, where would you go?HongKongIf you could visit one place in the world, where would you go?Beside youIf you could visit one place in the world, where would you go?KyotoBeside you: 1Shanghai: 1Tokyo: 2Kyoto: 2HongKong: 3America: 1 Description (function)Select from exercise 8-1 to 8-16 Code (function)8-2123456# 8-2 喜欢的图书 ：编写一个名为favorite_book() 的函数，其中包含一个名为title 的形参。这个函数打印一条消息，# 如One of my favorite books is Alice in Wonderland 。调用这个函数，并将一本图书的名称作为实参传递给它。def favorite_book( title): print("One of my favorite books is "+title.title())favorite_book(input("Which book do you like best?")) result:12Which book do you like best?harry potterOne of my favorite books is Harry Potter 8-41234567891011# 8-3 T恤 ：编写一个名为make_shirt() 的函数，它接受一个尺码以及要印到T恤上的字样。这个函数应打印一个句子，# 概要地说明T恤的尺码和字样。使用位置实参调用这个函数来制作一件T恤；再使用关键字实参来调用这个函数。# 8-4 大号T恤 ：修改函数make_shirt() ，使其在默认情况下制作一件印有字样“I love Python”的大号T恤。# 调用这个函数来制作如下T恤：一件印有默认字样的大号T恤一件印有默认字样的中号T恤和一件印有其他字样的T恤（尺码无关紧要）。def make_shirt( size, slogen = "I love Python!"): print("Size: " + size) print("Print with: "+slogen)make_shirt("XXL")make_shirt("L", "Hello world") result:1234Size: XXLPrint with: I love Python!Size: LPrint with: Hello world 8-6123456789# 8-6 城市名 ：编写一个名为city_country() 的函数，它接受城市的名称及其所属的国家。这个函数应返回一个格式类似于下面这样的字符串：# "Santiago, Chile"# 至少使用三个城市-国家对调用这个函数，并打印它返回的值。def city_country(country, city): return city+", "+countryprint(city_country("China", "Guangzhou"))print(city_country("Japan", "Tokyo"))print(city_country("America", "Los Angeles")) result:123Guangzhou, ChinaTokyo, JapanLos Angeles, America 8-141234567891011121314# 8-14 汽车 ：编写一个函数，将一辆汽车的信息存储在一个字典中。这个函数总是接受制造商和型号，还接受任意数量的关键字实参。这样调用这个函数：提供必不可# 少的信息，以及两个名称—值对，如颜色和选装配件。这个函数必须能够像下面这样进行调用：# car = make_car('subaru', 'outback', color='blue', tow_package=True)def make_car( brand, type, **car_info): car = &#123;&#125; car["brand"] = brand car["type"] = type for key, value in car_info.items(): car[key] = value return carprint(make_car("BMW", "gas", color="black", price="100 milions"))print(make_car("Benz", "gas",))print(make_car("Tesla", "eletric", appearance="cool")) result:123&#123;'brand': 'BMW', 'type': 'gas', 'color': 'black', 'price': '100 milions'&#125;&#123;'brand': 'Benz', 'type': 'gas'&#125;&#123;'brand': 'Tesla', 'type': 'eletric', 'appearance': 'cool'&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bochs虚拟机安装及使用]]></title>
    <url>%2F2018%2F03%2F19%2FBochs%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在学习操作系统时需要用虚拟机进行实验，Bochs虚拟机即是免费的又能够在里面进行调试，因此现在改用Bohcs虚拟机。以下记录了安装和配置的过程(仅在windows下)。 下载安装Bochs可以在此处进行下载： 下载完成后运行安装，建议安装到不需要管理员权限的位置。 配置虚拟机参考自，在bochs根目录下新建一个文件bochsrc，内容为：1234567891011121314megs:32romimage:file=$BXSHARE/BIOS-bochs-latestvgaromimage:file=$BXSHARE/VGABIOS-lgpl-latestfloppya:1_44=a.img,status=insertedboot:floppylog:bochsout.txtmouse:enabled=0keyboard: keymap=$BXSHARE/keymaps/x11-pc-de.map 其中，floppya为A盘的软盘映像，若需要使用B盘，可以加上一行floppyb的配置。 创建虚拟软盘运行bximage，进行软盘创建： 可以看到这个默认的a.img就是上一步中的a盘，我们将二进制文件复制进去运行。 运行虚拟机在Bochs的根目录下，按shift+右键打开power shell窗口，输入1.\bochs.exe -qf bochsrc 运行刚刚配置好的虚拟机（注意，此时a.img中的首扇区必须有正确格式的引导程序，否则会报错） 使用dd进行文件合并在修改软盘时，每次都要用WinHex进行手动修改实在是太麻烦了，Linux上有dd进行文件合并、分割，万幸，在Windows下也有dd for Windows可以帮助我们进行文件合并与分割，下载链接在这里(已修改) 使用时，可以用以下语句：1dd if=3_2_0.bin of=a.img bs=512 count=1 if：输入文件 of：输出文件 bs：每一块的默认大小（512字节） seek：在输出时，跳过of的块数量 skip：在复制时，跳过if的块数量 count：复制的块的数量 conv：输出时文件格式，其中conv=notrunc为不截断输出文件 还有其它参数及conv的其它值可进行选择，这里只举出常用的不一一列举。]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python作业03-条件语句&字典]]></title>
    <url>%2F2018%2F03%2F19%2Fpython%E4%BD%9C%E4%B8%9A03-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%26%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[Description (if)Select from exercise 5-1 to 5-13 Code (if)5-31234567891011# 5-3 外星人颜色#1 ：假设在游戏中刚射杀了一个外星人，请创建一个名为alien_color 的变量，# 并将其设置为'green' 、'yellow' 或'red' 。# 编写一条if 语句，检查外星人是否是绿色的；如果是，就打印一条消息，指出玩家获得了5个点。# 编写这个程序的两个版本，在一个版本中上述测试通过了，而在另一个版本中未通过（未通过测试时没有输出）。alien_color = "green"if alien_color == "green": print("Get 5 points!")alien_color = "yellow"if alien_color == "green": print("Get 5 points!") result:1Get 5 points! 5-61234567891011121314151617181920# 5-6 人生的不同阶段 ：设置变量age 的值，再编写一个if-elif-else 结构，根据age 的值判断处于人生的哪个阶段。def howold(age): if age&lt;2: print("a baby")# 如果一个人的年龄小于2岁，就打印一条消息，指出他是婴儿。 elif age&lt;4: print("learning how to walk")# 如果一个人的年龄为2（含）～4岁，就打印一条消息，指出他正蹒跚学步。 elif age&lt;13: print("a child")# 如果一个人的年龄为4（含）～13岁，就打印一条消息，指出他是儿童。 elif age&lt;20: print("a teenage")# 如果一个人的年龄为13（含）～20岁，就打印一条消息，指出他是青少年。 elif age&lt;65: print("an adult")# 如果一个人的年龄为20（含）～65岁，就打印一条消息，指出他是成年人。 else: print("the old")# 如果一个人的年龄超过65（含）岁，就打印一条消息，指出他是老年人。howold(1)howold(3)howold(5)howold(18)howold(24)howold(90) result:123456a babylearning how to walka childa teenagean adultthe old 5-81234567891011# 5-8 以特殊方式跟管理员打招呼 ：创建一个至少包含5个用户名的列表，且其中一个用户名为'admin' 。# 想象你要编写代码，在每位用户登录网站后都打印一条问# 候消息。遍历用户名列表，并向每位用户打印一条问候消息。# 如果用户名为'admin' ，就打印一条特殊的问候消息，如“Hello admin, would you like to see a status report?”。# 否则，打印一条普通的问候消息，如“Hello Eric, thank you for logging in again”。users = ["Eric", "Kris", "Smith", "admin", "Harry"]for user in users: if user == "admin": print("Hello admin, would you like to see a status report?") else: print("Hello "+user+", thank you for logging in again!") result:12345Hello Eric, thank you for logging in again!Hello Kris, thank you for logging in again!Hello Smith, thank you for logging in again!Hello admin, would you like to see a status report?Hello Harry, thank you for logging in again! 5-9123456789101112# 5-9 处理没有用户的情形 ：在为完成练习5-8编写的程序中，添加一条if 语句，检查用户名列表是否为空。# 如果为空，就打印消息“We need to find some users!”。# 删除列表中的所有用户名，确定将打印正确的消息users = []if users: for user in users: if user == "admin": print("Hello admin, would you like to see a status report?") else: print("Hello " + user + ", thank you for logging in again!")else: print("We need to find some users!") result:1We need to find some users! 5-11123456789101112131415# 5-11 序数 ：序数表示位置，如1st和2nd。大多数序数都以th结尾，只有1、2和3例外。# 在一个列表中存储数字1~9。# 遍历这个列表。# 在循环中使用一个if-elif-else 结构，以打印每个数字对应的序数。输出内容应为1st 、2nd 、3rd 、4th 、5th 、# 6th 、7th 、8th 和9th ，但每个序数都独占一行。numbers = range(1, 10)for number in numbers: if number == 1: print('1st') elif number == 2: print('2nd') elif number == 3: print('3rd') else: print(str(number)+'th') result:1234567891st2nd3rd4th5th6th7th8th9th Description (dictionary)Select from exercise 6-1 to 5-13 Code (dictionary)6-31234567891011121314# 6-3 词汇表 ：Python字典可用于模拟现实生活中的字典，但为避免混淆，我们将后者称为词汇表。# 想出你在前面学过的5个编程词汇，将它们用作词汇表中的键，并将它们的含义作为值存储在词汇表中。# 以整洁的方式打印每个词汇及其含义。为此，你可以先打印词汇，在它后面加上一个冒号，再打印词汇的含义；也可在一行打印词汇，# 再使用换行符（\n ）插入一个空行，然后在下一行以缩进的方式打印词汇的含义。words = &#123; 'if': 'if what happen then do something', 'while': 'loop', 'or': 'in bool, A happens or B happens are both fine', 'var': 'record some number, string, dictionary etc', 'python': 'easy to get star'&#125;print('python: '+words['python']+'.')print('if: '+words['if']+'.') result:12python: easy to get star.if: if what happen then do something. 6-41234567891011# 6-4 词汇表2 ：既然你知道了如何遍历字典，现在请整理你为完成练习6-3而编写的代码，将其中的一系列print# 语句替换为一个遍历字典中的键和值的循环。确定该循环正确无误后，再在词汇表中添加5个Python术语。# 当你再次运行这个程序时，这些新术语及其含义将自动包含在输出中。words['import'] = 'as include in c'words['for'] = 'another loop'words['and'] = 'only if A and B both true'words['class'] = 'var define by coder'words['print'] = 'to print string and begin a new line'for key in words.keys(): print(key + ': '+words[key]+'.') result:12345678910if: if what happen then do something.while: loop.or: in bool, A happens or B happens are both fine.var: record some number, string, dictionary etc.python: easy to get star.import: as include in c.for: another loop.and: only if A and B both true.class: var define by coder.print: to print string and begin a new line. 6-8123456789101112131415161718#6-8 宠物 ：创建多个字典，对于每个字典，都使用一个宠物的名称来给它命名；在每个字典中，# 包含宠物的类型及其主人的名字。将这些字典存储在一个名为pets的列表中，再遍历该列表，并将宠物的所有信息都打印出来。pets = [&#123;"name": "Kingkong", "type": "dog", "master": "Tony"&#125;, &#123;"name": "Kitty", "type": "cat", "master": "Jessica"&#125;, &#123;"name": "Big Bird", "type": "snake", "master": "Jason"&#125;, &#123;"name": "Son", "type": "kangaroo", "master": "Micheal"&#125;, ]for pet in pets: print(pet["name"]+" is a "+pet["type"]+", it is "+pet["master"]+"'s friend!") result:1234Kingkong is a dog, it is Tony's friend!Kitty is a cat, it is Jessica's friend!Big Bird is a snake, it is Jason's friend!Son is a kangaroo, it is Micheal's friend!]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业02-列表]]></title>
    <url>%2F2018%2F03%2F13%2FPython%E4%BD%9C%E4%B8%9A02-%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 3-1 to 4-15 Code3-1 &amp; 3-212345678# 3-1 姓名: 将一些朋友的姓名存储在一个列表中，并将其命名为names。# 依次访问该列表中的每个元素，从而将每个朋友的姓名都打印出来。# 3-2 问候语：继续使用练习3-1中的列表，但不打印每个朋友的姓名，# 而为每人打印一条消息。每条消息都包含相同的问候语，但抬头为相应朋友的姓名。names = ["tony", "marry","tom","ma"]for name in names: print(name.title()+": ") print("Hello, "+name+" .") result: 12345678910Tony: Hello, tony .Marry: Hello, marry .Tom: Hello, tom .Ma: Hello, ma .Process finished with exit code 0 3-4 ~ 3-73-4123456# 3-4 嘉宾名单 ：如果你可以邀请任何人一起共进晚餐（无论是在世的还是故去的），# 你会邀请哪些人？请创建一个列表，其中包含至少3个你想邀请的人；# 然后，使用这个列表打印消息，邀请这些人来与你共进晚餐。names = ["Tom","Raker", "Gakki"]for name in names: print("Hi, "+name+" .Would you like to have dinner with me?") result: 123Hi, Tom .Would you like to have dinner with me?Hi, Raker .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-512345678# 3-5 以完成练习3-4时编写的程序为基础，在程序末尾添加一条print 语句，指出哪位嘉宾无法赴约。# 修改嘉宾名单，将无法赴约的嘉宾的姓名替换为新邀请的嘉宾的姓名。# 再次打印一系列消息，向名单中的每位嘉宾发出邀请。new_name = "Tony"print(names[1]+" cannot come, "+new_name+" will instead.")names[1] = new_namefor name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234Raker cannot come, Tony will instead.Hi, Tom .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me? 3-6123456789101112# 3-6 添加嘉宾 ：你刚找到了一个更大的餐桌，可容纳更多的嘉宾。请想想你还想邀请哪三位嘉宾。# 以完成练习3-4或练习3-5时编写的程序为基础，在程序末尾添加一条print 语句，指出你找到了一个更大的餐桌。# 使用insert() 将一位新嘉宾添加到名单开头。# 使用insert() 将另一位新嘉宾添加到名单中间。# 使用append() 将最后一位新嘉宾添加到名单末尾。# 打印一系列消息，向名单中的每位嘉宾发出邀请。print("Good news! I find a larger table!")names.insert(0,"Dollus")names.insert(2,"Sam")names.append("Lilith")for name in names: print("Hi, " + name + " .Would you like to have dinner with me?") result: 1234567Good news! I find a larger table!Hi, Dollus .Would you like to have dinner with me?Hi, Tom .Would you like to have dinner with me?Hi, Sam .Would you like to have dinner with me?Hi, Tony .Would you like to have dinner with me?Hi, Gakki .Would you like to have dinner with me?Hi, Lilith .Would you like to have dinner with me? 3-71234567891011121314# 3-7 缩减名单 ：你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。# 以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。# 使用pop() 不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。# 对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。# 使用del 将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的。print("I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.")while len(names)&gt;2: sorry_name = names.pop() print("Hi "+sorry_name+", I'm sorry to tell you that I cannot have dinner with you.")for name in names: print("Hey "+name+", you are still in my invite list!")del names[0]del names[0]print(names) result: 12345678I'm sorry to tell you that, my new table cannot arrive in time, so I can only invite 2.Hi Lilith, I'm sorry to tell you that I cannot have dinner with you.Hi Gakki, I'm sorry to tell you that I cannot have dinner with you.Hi Tony, I'm sorry to tell you that I cannot have dinner with you.Hi Sam, I'm sorry to tell you that I cannot have dinner with you.Hey Dollus, you are still in my invite list!Hey Tom, you are still in my invite list![] 3-8 ~ 3-113-81234567891011121314151617181920212223242526272829303132333435# 3-8 放眼世界 ：想出至少5个你渴望去旅游的地方。places = ["Egypt", "Tibet", "France", "Russia", "Australia"]# 将这些地方存储在一个列表中，并确保其中的元素不是按字母顺序排列的。print("按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:")print(places)print("使用sorted() 按字母顺序打印这个列表，同时不要修改它:")print(sorted(places))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:")print(sorted(places, reverse=True))print("再次打印该列表，核实排列顺序未变:")print(places)print("使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:")places.reverse()print(places)print("使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:")places.reverse()print(places)print("使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:")places.sort()print(places)print("使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:")places.sort(reverse=True)print(places) result: 1234567891011121314151617181920按原始排列顺序打印该列表。不要考虑输出是否整洁的问题，只管打印原始Python列表:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按字母顺序打印这个列表，同时不要修改它:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sorted() 按与字母顺序相反的顺序打印这个列表，同时不要修改它:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']再次打印该列表，核实排列顺序未变:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用reverse() 修改列表元素的排列顺序。打印该列表，核实排列顺序确实变了:['Australia', 'Russia', 'France', 'Tibet', 'Egypt']使用reverse() 再次修改列表元素的排列顺序。打印该列表，核实已恢复到原来的排列顺序:['Egypt', 'Tibet', 'France', 'Russia', 'Australia']使用sort() 修改该列表，使其元素按字母顺序排列。打印该列表，核实排列顺序确实变了:['Australia', 'Egypt', 'France', 'Russia', 'Tibet']使用sort() 修改该列表，使其元素按与字母顺序相反的顺序排列。打印该列表，核实排列顺序确实变了:['Tibet', 'Russia', 'France', 'Egypt', 'Australia']Process finished with exit code 0 3-912# 使用len()打印一条消息，指出想要游玩多少个国家。print("I want to go "+str(len(places))+" places.") result: 1I want to go 5 places. 3-111234# 3-11 有意引发错误 ：如果你还没有在程序中遇到过索引错误，就尝试引发一个这种错误。# 在你的一个程序中，修改其中的索引，以引发索引错误。关闭程序前，# 务必消除这个错误。print(places[7]) result: 123File "D:/pyproject/homework1/3-8.py", line 43, in &lt;module&gt; print(places[7])IndexError: list index out of range 4-212345678910# 4-2 动物 ：想出至少三种有共同特征的动物，将这些动物的名称存储在一个列表中，再使用for 循环将每种动物的名称都打印出来。animals = ["dog", "cat", "hamster"]for animal in animals: print(animal)# 修改这个程序，使其针对每种动物都打印一个句子，如“A dog would make a great pet”。for animal in animals: print("A "+animal+" would make a good pet.")# 在程序末尾添加一行代码，指出这些动物的共同之处，如打印诸如“Any of these animals would make a great pet!”这样的句子。print("Any of these animals would make a greate pet!") result:123456789dogcathamsterA dog would make a good pet.A cat would make a good pet.A hamster would make a good pet.Any of these animals would make a greate pet!Process finished with exit code 0 4-3 ~ 4-94-3123# 4-3 数到20 ：使用一个for 循环打印数字1~20（含）。for number in range(1, 21): print(number) result:12345678910111213141516171819201234567891011121314151617181920 4-5123456# 4-5 计算1~1 000 000的总和 ：创建一个列表，其中包含数字1~1 000 000，再使用min() 和max() 核实该列表确实是从1开始，# 到1 000 000结束的。另外，对这个列表调用函数sum() ，看看Python将一百万个数字相加需要多长时间。numbers = range(1, 1000001)print(min(numbers))print(max(numbers))print(sum(numbers)) result:12311000000500000500000 4-61234# 4-6 奇数 ：通过给函数range() 指定第三个参数来创建一个列表，其中包含1~20的奇数；再使用一个for 循环将这些数字都打印出来。odd_numbers = range(1,20,2)for odd_number in odd_numbers: print(odd_number) result:12345678910135791113151719 4-9123# 4-9 立方解析 ：使用列表解析生成一个列表，其中包含前10个整数的立方。cube_numbers = [ number**3 for number in range(1,11)]print(cube_numbers) result:1[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] 4-10 &amp; 4-114-1012345678910# 4-10 切片 ：选择你在本章编写的一个程序，在末尾添加几行代码，以完成如下任务。# 打印消息“The first three items in the list are:”，再使用切片来打印列表的前三个元素。# 打印消息“Three items from the middle of the list are:”，再使用切片来打印列表中间的三个元素。# 打印消息“The last three items in the list are:”，再使用切片来打印列表末尾的三个元素。print("The first three items in the list are:")print(cube_numbers[:3])print("Three items from the middle of the list are:")print(cube_numbers[3:6])print("The last three items in the list are:")print(cube_numbers[6:]) result:123456The first three items in the list are:[1, 8, 27]Three items from the middle of the list are:[64, 125, 216]The last three items in the list are:[343, 512, 729, 1000] 4-11copy a list123456789101112131415161718print("list A:")A = ["A", "E", "I", "O"]print(A)print("list B copy from A:")B = A[:]print(B)print("Change B and A didn't change:")B.append("U")print(A)print(B)print("C equal to A directly:")C = Aprint(A)print(C)print("C change and make A change:")C.pop()print(A)print(C) result:12345678910111213list A:['A', 'E', 'I', 'O']list B copy from A:['A', 'E', 'I', 'O']Change B and A didn't change:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O', 'U']C equal to A directly:['A', 'E', 'I', 'O']['A', 'E', 'I', 'O']C change and make A change:['A', 'E', 'I']['A', 'E', 'I'] 4-1312345# 4-13 自助餐 ：有一家自助式餐馆，只提供五种简单的食品。请想出五种简单的食品，并将其存储在一个元组中。# 使用一个for 循环将该餐馆提供的五种食品都打印出来。foods = ("apple", "juice", "pizza", "noodles", "egg")for food in foods: print(food) result:12345applejuicepizzanoodlesegg 12# 尝试修改其中的一个元素，核实Python确实会拒绝你这样做。foods[3] = "chicken" result:123456Traceback (most recent call last): File "D:/pyproject/homework1/4-2.py", line 18, in &lt;module&gt; foods[3] = "chicken"TypeError: 'tuple' object does not support item assignmentProcess finished with exit code 1 12345# 餐馆调整了菜单，替换了它提供的其中两种食品。请编写一个这样的代码块：# 给元组变量赋值，并使用一个for 循环将新元组的每个元素都打印出来。foods = ("apple", "cola", "cabbage", "noodles", "egg")for food in foods: print(food) result:12345applecolacabbagenoodlesegg PEP格式指南 四空格缩进 行最长不超过80字符 不要在程序中过多地使用空行 适当的注释 …]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello blog again]]></title>
    <url>%2F2018%2F03%2F11%2Fhello-blog-again%2F</url>
    <content type="text"><![CDATA[之前的博客是直接克隆自他人的博客代码再进行修改，不太好意思。而且不自己从开始建的话，很多配置用不了、不知道如何更改，因此趁周末闲暇从新用hexo建站并上传至GitHub Pages，并配置好了主题等，特地记录一下踩过的、好的文章和添加的功能。 搭建过程及相关教程下载hexo在桌面右键选择Git Bash here，并输入 npm install -g hexo-cli 等待安装，找个网络比较好的地方等吧…… 接下来具体的部署内容详见这个教程，算是见得比较全的一篇教程了。 添加主题NexT将主题下载然后放进/theme，我这里用的是NexT主题。具体参见NexT项目，以及使用文档 添加的功能 RSS订阅 添加分类页 背景动画 站内搜索 访问量统计 使用Gitment添加评论 支持markdown代码高亮 踩过的坑markdown编辑器的选择一开始用的NotePad++，首先是不支持预览，其次是它的front-matter添加后会被当成普通的markdown语法。因此现在改用vscode进行markdown的编辑器。 具体的使用方法：打开.md文件进行编辑，按Ctrl+k再按v即可打开预览窗口，效果如下： 使用Gitment添加评论 NexT预置Gitment： 一开始使用Gitment添加时找到的是过去版本的教程，需要修改代码，但是在修改的过程中突然发现原本的文件已经包含了Gitment模块，这才知道NexT的新版本已经预置了Gitment，配置方法参考自这里。 关于Error: Not Found: 配置时要注意仓库名称要是该仓库本名，而非SSH或HTTPS，例如我的就是Skyraker.github.io。 关于Error：validation failed: Gitment的原理就是在关联你的项目，每一个页面下的评论对应一个issue，并给那个issue建立标签gitment和id，其中id是Gitment唯一确定评论显示于哪个位置的特征。而出现Error：validation failed是因为id超出了issue的50个字符的限制。这个id是怎么来的呢？ 在相应的主题中搜索Gitment即可定位至gitment.swig，打开找到id可以看到： id: window.location.pathname, 即当前id为这个页面在本站中的路径。当文章title为中文时，转码会导致id过长。我们可以改路径名（即permlink）,具体详见这里，或者改id为 id: &apos;{{ page.date }}&apos; 或 id: &apos;{{ page.title }}&apos; 以缩短id，但注意这两个数据必须是唯一的，不能重复，否则评论会在多个页面共享。参考并修改自这里 初始化本页页面后，可能没那么快加载出来，不要重复初始化，否则会出现两个相同的issue 代码高亮在站点配置文件中，修改配置： highlight: enable: true auto_detect: true line_number: true tab_replace: 即可打开代码高亮的自动探测、行号显示。 在主题配置文件中，修改配置选择高亮风格： 12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 最后在编辑markdown时，引用代码，可以得到如下效果：123456#include &lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Hello world!"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OS学习笔记01-接管裸机控制权]]></title>
    <url>%2F2018%2F03%2F10%2FOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(01)%E6%8E%A5%E7%AE%A1%E8%A3%B8%E6%9C%BA%E6%8E%A7%E5%88%B6%E6%9D%83%2F</url>
    <content type="text"><![CDATA[实验任务设计一个引导扇区程序，程序功能是：在屏幕上显示运动内容，并在触碰到边框时反弹，可以加入变色等其它功能。将这个程序的机器码放进放进虚拟软盘的首扇区，并用此软盘引导无操作系统的虚拟机，直到成功。 基础原理主引导记录（MBR）工作原理：计算机启动后，由BIOS检查硬件并根据指定的顺序，检查引导设备（本次实验中的虚拟软盘）的第一扇区（即前512B且以0x55AA结尾的内容，也就是我们的主引导记录），加载至内存地址0x7C00，并开始运行；其它内存地址如下所示： 显示原理：显存首地址为0xB800，以两个字节来控制相应屏幕位置的显示内容。其中低字节为显示字符的ascii码，高字节为显示颜色，显示颜色如下表： 其中，颜色默认为0x07，即黑底白字； 实验工具和环境说明 编辑器：Notepad++，支持语法高亮； 汇编器：NASM，与MASM有部分区别，后文详述； 机器码编辑器：WinHex，用于对COM进行修改使其符合MBR的格式 虚拟机：VMware，用于生成裸机 程序流程及源码显示个人信息跳动规迹，并变色； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222;显示学号姓名缩写 DRt equ 1 ;D-Down,U-Up,R-right,L-Left URt equ 2 ; ULt equ 3 ; DLt equ 4 ; delay equ 50000 ;计时器延迟计数,用于控制画框的速度 ddelay equ 580 ;延迟580*50000次 Hm equ 25 ;最大高度 Lm equ 80 ;最大宽度 len equ 14 ;字符串长度 BOOTSEG equ 0x7c00 ;段基址0x7c00 DISPLAYSEG equ 0xb800 ;显存及地址0xb800 org BOOTSEG ;告诉汇编器要在0x7c00执行 section .text_start: ;初始化数据段，使其指向0X7C00处，即Boot代码被加载的地方 mov ax, cs mov ds, ax ;将文本显示内存段基址 放在ES中，供后面显示字符使用 mov ax, DISPLAYSEG mov es, ax loop1: dec word[count] ; 递减计数变量 jnz loop1 ; &gt;0：跳转; mov word[count],delay dec word[dcount] ; 递减计数变量 jnz loop1 mov word[count],delay mov word[dcount],ddelay ;mov al, 20H ;空格覆盖 ;mov ah, 0FH ;mov [es:bx], ax dec byte[color] cmp byte[color], 01H jz resetback: mov al, DRt ;↘ cmp al, byte[dir] jz DRF mov al, DLt ;↙ cmp al, byte[dir] jz DLF mov al, URt ;↗ cmp al, byte[dir] jz URF mov al, ULt ;↖ cmp al, byte[dir] jz ULF jmp $DRF: inc word[x] inc word[y] ;向右下前进一格 mov ax, Hm mov bx, word[x] ;判断x是否越界 cmp ax, bx jz dr2ur mov ax, Lm-len mov bx, word[y] ;判断y是否越界 cmp ax, bx jz dr2dl jmp displaydr2ur: ;回弹——从右下改为右上 mov word[x], Hm-2 mov ax, Lm-len ;判断是否为角落 mov bx, word[y] cmp ax, bx jz drA mov byte[dir], URt jmp displaydr2dl: mov word[y], Lm-len-2 mov byte[dir], DLt jmp displaydrA: ;角落时原路返回 mov word[y],Lm-len-2 mov byte[dir], ULt jmp display DLF: inc word[x] dec word[y] mov ax, Hm mov bx, word[x] cmp ax, bx jz dl2ul mov ax, -1 mov bx, word[y] cmp ax, bx jz dl2dr jmp displaydl2ul: mov word[x], Hm-2 mov ax, -1 mov bx, word[y] cmp ax, bx jz dlA mov byte[dir], ULt jmp displaydl2dr: mov word[y], 1 mov byte[dir], DRt jmp displaydlA: mov word[y], 1 mov byte[dir], URt jmp display URF: dec word[x] inc word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ur2dr mov ax, Lm-len mov bx, word[y] cmp ax, bx jz ur2ul jmp displayur2dr: mov word[x], 1 mov ax, Lm-len mov bx, word[y] cmp ax, bx jz urA mov byte[dir], DRt jmp displayur2ul: mov word[y], Lm-len-2 mov byte[dir], ULt jmp displayurA: mov word[y], Lm-len-2 mov byte[dir], DLt jmp display ULF: dec word[x] dec word[y] mov ax, -1 mov bx, word[x] cmp ax, bx jz ul2dl mov ax, -1 mov bx, word[y] cmp ax, bx jz ul2ur jmp displayul2dl: mov word[x], 1 mov ax, -1 mov bx, word[y] cmp ax, bx jz ulA mov byte[dir], DLt jmp displayul2ur: mov word[y], 1 mov byte[dir], URt jmp displayulA: mov word[y], 1 mov byte[dir], DRt jmp display display: ;显示模块 mov ax, word[x] mov bx, Lm mul bx add ax, word[y] mov bx, 2 mul bx mov bx, ax ;bx = ax = (x*80+y) * 2 mov cx, len mov si, info mov ah, [color]loop_str: ;字符串显示模块 mov al, [si] mov [es:bx], ax inc si inc bx inc bx loop loop_str jmp loop1reset: mov byte[color], 0FH jmp backend: jmp $;section .data info db " ygz 16337287 ",0 count dw delay dcount dw ddelay dir db DRt ; 向右下运动 x dw 2 y dw 0 color db 0FH times 510-($-$$) db 0 ;填充空格 dw 0xaa55 实验步骤 在NotePad++中进行编辑程序; 在生成软盘文件： 打开CMD终端窗口至asm文件所在的文件夹，输入nasm -f bin %name%.asm -o %name%.com &gt; amsg.txt（%name%为文件名）； 或直接输入na %name%.asm快速生成com文件，na.bat内容如下：@echo offset name=%~n1nasm -f bin %name%.asm -o %name%.COM &gt; amsg.txttype amsg.txt |find “Error”type amsg.txt |find “Warn” 生成com文件，打开com文件将0x1FE和0x1FF改为0x55和0xAA，保存为flp软盘格式: 另：若代码末尾已经加上了times 510-($-$$) db 0 ;填充空格dw 0xaa55 ;加上55AA，符合MBR特征则不必再修改com文件，直接生成为flp文件即可 创建无操作系统的裸机： 将flp文件装载进虚拟机作为MBR引导启动： 结果截图 显示有规迹的‘A’： 显示动态无规迹的‘A’+固定的个人信息‘ ygz 16337287 ’： 逐字显示动态变色个人信息，并保留痕迹： 整行显示动态变色个人信息： 接下来就是各种踩坑和填坑的经历了 关于NASM： NASM的标识符区分大小写； NASM中，memory操作数直接是内容地址，并且不保存数据类型，导致以下两个区别： 在读取数据内容时，要加方括号[ ] 指明是地址的内容，若没有方括号则是首地址的值； 在操作数据内容时且另一个操作数是常数（非ax、ah这种能够知道数据大小的寄存器），要加上数据类型如byte、word等； 不需要ptr指示字； 提供segment时，NASM要在方括号内提供segment，如：MOV [es:bx], ax 段定义方式，NASM定义数据段section .data，定义代码段section .text equ类似C语言中的define，用于定义整数常量；（注意，不能定义浮点数，且最长为8bytes） 用times来重复定义数据或指令 $为当前nasm编译后当前指令位置，$$为该段的初始位置。一开始在没弄懂$$的情况下照猫画虎胡乱使用，导致生成的文件大于512B且0x55AA位置错误（虽然没有影响），后来去掉了section .data后即可（即让后面的数据处于与代码的同一段，以便于计算总体机器码的大小）。 其它的NASM需要注意的语法待后面的实验探索。关于加载至0x7c00：BIOS检查了引导设备的第一个扇区（以0x55AA结尾的512B）即主引导记录（MBR），加载至0x7c00，因此默认偏移为0x7c00。至于为什么时0x7c00，是由于一开始的8088CPU内存为32KB，即0~0x7FFF，保留512B给MBR，512B保留给MBR产生的数据，为了让出足够的空间给操作系统，因此从后开始算，0x7FFF-1024 = 0x7c00;关于org的作用及思考：根据上一条，我们的代码将会被强制加载到0x7c00，因此若没有org，后面的memory操作数会默认从0开始算。 例如在相对位置3做了如下定义： msg db ‘@’ 在没有org的情况下，[msg]会在0x03读取一位，而真正的数据‘@’被加载到了0x7c03，在读取[msg]的时候就会读到乱码。 在有org 0x7c00的情况下，[msg]会直接去0x7c03读取’@’。 以上可以在生成机器码后，通过反汇编看出。总的来说，org就是告诉汇编器，该代码必然会被加载到某一偏移值上，因此要告诉汇编器后面的相对地址要加上偏移值。 这也就能够解释一个现象：明明在数据段中初始化了数据，却无法读取，只能在代码开头重新mov一遍才能正常输出，但是重复mov时的目的地址为0x7c00前面的某个位置，造成别的内存的篡改，产生不可预计的后果。 关于算法的错误： 角落判断：在一开始的设计中，仅分别判断了x和y的位置，若字符运行至角落，仅仅将x反弹，而y会继续运动，而且运动方向也会错误，导致一次显示错误的同时也造成了y的越界，且会越跑越远，最终让字符完全移出屏幕，如下图可见在后期字符的反弹条件已经错误了 修改方法：在判断x越界后的反弹程序中，判断y是否同时越界，若是，则将路径原路返回 在部分不需要写回的相等判断中，用了sub，其实用cmp即可； 不足及优化设想：在整体信息输出弹跳时，本想着每次弹跳后才变色的，视觉效果会好很多，但是在弹跳时加了判断后（即十二种弹跳），会超出512B限制,导致部分指令无法装载。有两种优化设想： 将DRt等数据不局限于一个特征数，而是按规律如上下分别为1、0来进行编写，在弹跳时通过运算来更改路径，合并重复逻辑； 在MBR中进行引导而非操作，真正的操作放在操作系统的位置执行。 这两种方法都有待进一步的实践。 入门摸索，难免有纰漏，欢迎各位大佬批评指正 参考资料 “Hello world” 引导程序 NASM与MASM语法区别 主引导记录内存地址是0x7c00 关于org 0x7c00的原因]]></content>
      <categories>
        <category>OS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python作业01-变量和简单数据类型]]></title>
    <url>%2F2018%2F03%2F08%2F2018-03-08-Python%E4%BD%9C%E4%B8%9A01-%E5%8F%98%E9%87%8F%E5%92%8C%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[DescriptionSelect from exercise 2-1 to 2-11. I will finish the code with comment about the requirement. Code2-3123456# 2-3 个性化消息： 将用户的姓名存到一个变量中，# 并向该用户显示一条消息。显示的消息应非常简单，# 如“Hello Eric, would you like to learn some Python today?”。name = input()print("Hello " + name + ", would you like to learn some Python today?") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_3.py Jobs Hello Jobs, would you like to learn some Python today? Process finished with exit code 0 2-41234567# 2-4 调整名字的大小写： 将一个人名存储到一个变量中，# 再以小写、大写和首字母大写的方式显示这个人名。name = input()print(name.upper())print(name.lower())print(name.title()) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_4.py sKy raKeR SKY RAKER sky raker Sky Raker Process finished with exit code 0 2-71234567891011121314151617# 2-7 剔除人名中的空白： 存储一个人名，# 并在其开头和末尾都包含一些空白字符。# 务必至少使用字符组合"\t" 和"\n" 各一次。# 打印这个人名，以显示其开头和末尾的空白。# 然后，分别使用剔除函数lstrip() 、rstrip()# 和strip() 对人名进行处理，并将结果打印出来。name = "\n\tSky Raker\t\n\t"print("-------------")print(name)print("-------------")print(name.lstrip())print("-------------")print(name.rstrip())print("-------------")print(name.strip())print("-------------") result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_7.py ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Sky Raker ------------- Process finished with exit code 0 2-812345678# 2-8 数字8： 编写4个表达式，它们分别使用# 加法、减法、乘法和除法运算，但结果都是数字8。# 为使用print 语句来显示结果，务必将这些表达式用括号括起来，print(3+5)print(10-2)print(2*4)print(1000/125) result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_8.py 8 8 8 8.0 Process finished with exit code 0 2-111234# 2-11 Python之禅： 在Python终端会话中执行命令import this ，# 并粗略地浏览一下其他的指导原则。import this result: D:\pyproject\homework1\venv\Scripts\python.exe D:/pyproject/homework1/2_11.py The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! Process finished with exit code 0]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Python]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Python%2F</url>
    <content type="text"><![CDATA[Python 的优点作为一个流行的解释型语言，python具有以下优点： 拥有许多强大的库，以支持python在各个领域的使用，也是许多人开始学习python的原因,例如： Web框架方面的Django等 科学计算方面的NumPy和SciPy等 用于解析HTML等的BeautifulSoup 用于图像处理的PIL以及支持python3的Pillow 用于多媒体、游戏开发的PyGame 机器学习的scikit-learn … 对初学者友好的学习曲线 … Python 的使用若仅仅进行少量的代码编写，可以使用文本编辑器写python代码再放到解释器下运行。若要进行更多的开发，可以用IDE，例如PyCharm、Eclipse&#39;s PyDev或轻量级的Geany。我目前使用的是PyCharm。 Python 官网探索在学习python之初，我们来看一下它官网的内容：Python 1. 社区：可以进行讨论交流、参与会议、参与活动等等； 2. 初学引导：初学者入门的手册、指南、帮助等； 3. 下载：python的相关下载、环境配置； 4. 帮助文档：在学习时要多参考帮助文档，里面有针对初学、进阶等各个阶段的帮助； 5. 最新关于python的新闻； 6. 即将到来的活动； 7. python的应用领域以及相关库； 网页上还有其它的类似成功故事、新闻、加入团队等链接就不一一赘述了。 目标 掌握python编程思想和基本语法，对常用库有一定的了解； 能够在日常生活中应用python脚本解决一些重复性的、机械的问题； 用python写爬虫，并学会用python进行数据处理； 希望能够利用python去学习一些机器学习的内容。 在python中输入import this，会出现一首诗Zen of Python: The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&apos;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&apos;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&apos;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&apos;s do more of those! 与各位共勉！]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello Blog]]></title>
    <url>%2F2018%2F03%2F06%2F2018-03-06-Hello-Blog%2F</url>
    <content type="text"><![CDATA[Hello Blog在很久之前就有搭一个自己的博客的想法，但是一直缺乏行动，同样的，一直想开始使用GitHub也没有静下心来研究一下。正巧《高级编程技术》的老师要求把作业项目提交到博客上，借着这次机会尝试使用GitHub Pages进行个人博客的搭建，尝试过hexo和jekyll都没有成功，只能cloneYanB大佬的博客，再参照所使用的NexT模板进行修改。另外，大佬还推荐了一个在线编辑GitHub Pages上博客的在线编辑平台prose，可以在线修改编辑博客并上传。很感谢大佬的教学！ 博客内容这个博客将会分享一些在学习过程中的心得、参与的项目以及其它的一些想分享的东西。未来或许会尝试用英文写作。希望能养成写博客的习惯，及时总结。 需要改进的地方 markdown的代码高亮配置。 虽然借助别人已经生成的模板也搭建出来了现在的这个博客，但依旧希望能够学会用jekyll并用来进行进一步的个性化调整。 挖掘博客的一些有趣的应用。]]></content>
      <categories>
        <category>others</category>
      </categories>
  </entry>
</search>
